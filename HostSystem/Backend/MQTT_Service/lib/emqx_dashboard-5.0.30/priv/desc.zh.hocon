{
  "emqx_authn_api": {
    "authentication_get": {
      "desc": "列出全局认证的认证器。",
      "label": "列出认证器"
    },
    "authentication_id_delete": {
      "desc": "删除全局认证链上的指定认证器。",
      "label": "删除认证器"
    },
    "authentication_id_get": {
      "desc": "获取全局认证链上的指定认证器。emqx_dashboard_error_code_apiemqx_dashboard_error_code_api",
      "label": "获取指定认证器"
    },
    "authentication_id_position_put": {
      "desc": "调整全局认证链上指定认证器的顺序。",
      "label": "调整认证器顺序"
    },
    "authentication_id_put": {
      "desc": "更新全局认证链上的指定认证器。",
      "label": "更新指定认证器"
    },
    "authentication_id_status_get": {
      "desc": "获取全局认证链上指定认证器的指标与状态。",
      "label": "获取指定认证器的指标与状态"
    },
    "authentication_id_users_get": {
      "desc": "获取全局认证链上指定认证器中的用户列表。",
      "label": "获取指定认证器中的用户列表"
    },
    "authentication_id_users_post": {
      "desc": "向全局认证链上的指定认证器添加用户数据。",
      "label": "向指定认证器添加用户"
    },
    "authentication_id_users_user_id_delete": {
      "desc": "删除全局认证链上指定认证器中的指定用户数据。",
      "label": "在指定认证器删除指定用户"
    },
    "authentication_id_users_user_id_get": {
      "desc": "获取全局认证链上指定认证器中的指定用户数据。",
      "label": "获取指定用户数据"
    },
    "authentication_id_users_user_id_put": {
      "desc": "更新全局认证链上指定认证器中的指定用户数据。",
      "label": "更新指定用户数据"
    },
    "authentication_post": {
      "desc": "为全局认证链创建认证器。",
      "label": "创建认证器"
    },
    "is_superuser": {
      "desc": "是否是超级用户。",
      "label": "超级用户"
    },
    "like_user_id": {
      "desc": "使用用户 ID （username 或 clientid）模糊查询。",
      "label": "like_user_id"
    },
    "listeners_listener_id_authentication_get": {
      "desc": "列出监听器上的认证器。",
      "label": "列出监听器上的认证器"
    },
    "listeners_listener_id_authentication_id_delete": {
      "desc": "删除监听器认证链上的指定认证器。",
      "label": "删除监听器上的指定认证器"
    },
    "listeners_listener_id_authentication_id_get": {
      "desc": "获取监听器认证链上的指定认证器。",
      "label": "获取监听器上的指定认证器"
    },
    "listeners_listener_id_authentication_id_position_put": {
      "desc": "调整监听器认证链上指定认证器的顺序。",
      "label": "调整监听器上认证器的顺序"
    },
    "listeners_listener_id_authentication_id_put": {
      "desc": "更新监听器认证链上的指定认证器。",
      "label": "更新监听器上的指定认证器"
    },
    "listeners_listener_id_authentication_id_status_get": {
      "desc": "获取监听器认证链上指定认证器的状态。",
      "label": "获取监听器上指定认证器的状态"
    },
    "listeners_listener_id_authentication_id_users_get": {
      "desc": "列出监听器认证链上指定认证器中的用户数据。",
      "label": "列出监听器上指定认证器中的用户数据"
    },
    "listeners_listener_id_authentication_id_users_post": {
      "desc": "向监听器认证链上的指定认证器添加用户数据。",
      "label": "向监听器上指定认证器添加用户"
    },
    "listeners_listener_id_authentication_id_users_user_id_delete": {
      "desc": "删除监听器认证链上指定认证器中的指定用户数据。",
      "label": "删除监听器上指定认证器中的指定用户"
    },
    "listeners_listener_id_authentication_id_users_user_id_get": {
      "desc": "获取监听器认证链上指定认证器中的指定用户数据。",
      "label": "获取监听器上指定认证器中的指定用户数据"
    },
    "listeners_listener_id_authentication_id_users_user_id_put": {
      "desc": "更新监听器认证链上指定认证器中的指定用户数据。",
      "label": "更新监听器上指定认证器中的指定用户数据"
    },
    "listeners_listener_id_authentication_post": {
      "desc": "在监听器认证链上创建认证器。",
      "label": "在监听器上创建认证器"
    },
    "param_auth_id": {
      "desc": "认证器 ID。由认证方式与数据源组成 `{mechanism}:{built_in_database}`，如 `password_based:built_in_database`",
      "label": "认证器 ID "
    },
    "param_listener_id": {
      "desc": "监听器 ID。",
      "label": "监听器 ID"
    },
    "param_position": {
      "desc": "认证器在链中的位置。可能的值是 'front', 'rear', 'before:{other_authenticator_id}', 'after:{other_authenticator_id}'",
      "label": "认证器在链中的位置"
    },
    "param_user_id": {
      "desc": "用户 ID，根据设置的账号类型不同，可以是 username 或 clientid",
      "label": "用户 ID"
    }
  },
  "emqx_authn_http_schema": {
    "body": {
      "desc": "HTTP 请求体。",
      "label": "请求体"
    },
    "get": {
      "desc": "使用 HTTP Server 作为认证服务的认证器的配置项 (使用 GET 请求)。"
    },
    "headers": {
      "desc": "HTTP Headers 列表",
      "label": "请求头"
    },
    "headers_no_content_type": {
      "desc": "HTTP Headers 列表 (无 <code>content-type</code>) 。",
      "label": "请求头(无 content-type)"
    },
    "method": {
      "desc": "HTTP 请求方法。",
      "label": "请求方法"
    },
    "post": {
      "desc": "使用 HTTP Server 作为认证服务的认证器的配置项 (使用 POST 请求)。"
    },
    "request_timeout": {
      "desc": "HTTP 请求超时时长。",
      "label": "请求超时"
    },
    "url": {
      "desc": "认证 HTTP 服务器地址。",
      "label": "URL"
    }
  },
  "emqx_authn_jwt_schema": {
    "acl_claim_name": {
      "desc": "用于获取 ACL 规则的 JWT 声明名称。",
      "label": "ACL 声明名称"
    },
    "algorithm": {
      "desc": "JWT 签名算法，支持 HMAC (配置为 <code>hmac-based</code>）和 RSA、ECDSA (配置为 <code>public-key</code>)。",
      "label": "JWT 签名算法"
    },
    "cacertfile": {
      "desc": "包含 PEM 编码的 CA 证书的文件的路径。",
      "label": "CA 证书文件"
    },
    "certfile": {
      "desc": "包含用户证书的文件的路径。",
      "label": "证书文件"
    },
    "enable": {
      "desc": "启用/禁用 SSL。",
      "label": "启用/禁用 SSL"
    },
    "endpoint": {
      "desc": "JWKS 端点， 它是一个以 JWKS 格式返回服务端的公钥集的只读端点。",
      "label": "JWKS Endpoint"
    },
    "from": {
      "desc": "指定客户端连接请求中 JWT 的位置。",
      "label": "JWT 的位置"
    },
    "jwt_hmac": {
      "desc": "用于认证的 JWT 使用 HMAC 算法签发时的配置。"
    },
    "jwt_jwks": {
      "desc": "用于认证的 JWTs 需要从 JWKS 端点获取时的配置。"
    },
    "jwt_public_key": {
      "desc": "用于认证的 JWT 使用 RSA 或 ECDSA 算法签发时的配置。"
    },
    "keyfile": {
      "desc": "包含 PEM 编码的用户私钥的文件的路径。",
      "label": "私钥文件"
    },
    "public_key": {
      "desc": "用于验证 JWT 的公钥。",
      "label": "公钥"
    },
    "refresh_interval": {
      "desc": "JWKS 刷新间隔。",
      "label": "JWKS 刷新间隔"
    },
    "secret": {
      "desc": "使用 HMAC 算法时用于验证 JWT 的密钥",
      "label": "Secret"
    },
    "secret_base64_encoded": {
      "desc": "密钥是否为 base64 编码。",
      "label": "密钥是否为 Base64 编码"
    },
    "server_name_indication": {
      "desc": "服务器名称指示（SNI）。",
      "label": "服务器名称指示"
    },
    "ssl": {
      "desc": "SSL 选项。",
      "label": "SSL 选项"
    },
    "use_jwks": {
      "desc": "是否使用 JWKS。",
      "label": "是否使用 JWKS"
    },
    "verify": {
      "desc": "指定握手过程中是否校验对端证书。",
      "label": "Verify"
    },
    "verify_claims": {
      "desc": "需要验证的自定义声明列表，是一个由名称/值对组成的列表。指定一个键(Key)来查找 JWT 中对应的声明(Claim)，并提供一个预期值(Expected Value)来与声明的实际值进行比较，以确保只有满足特定条件的 JWT 才能被接受和使用。\n例如要求 JWT 中的特定声明(如 clientid)的值必须与当前连接的客户端 ID 相匹配。\n预期值可以使用以下占位符：\n- <code>${username}</code>: 将在运行时被替换为客户端连接时使用的用户名\n- <code>${clientid}</code>: 将在运行时被替换为客户端连接时使用的客户端 ID\n身份认证将确认 JWT 中的声明值（从密码字段中获取）与 <code>verify_claims</code> 中要求的内容是否匹配。",
      "label": "自定义声明检查"
    }
  },
  "emqx_authn_ldap_bind_schema": {
    "ldap_bind": {
      "desc": "使用 LDAP 绑定操作作为认证方式的认证器的配置项。"
    },
    "query_timeout": {
      "desc": "LDAP 查询超时时间",
      "label": "查询超时"
    }
  },
  "emqx_authn_ldap_schema": {
    "is_superuser_attribute": {
      "desc": "指示哪个属性用于表示用户是否为超级用户。",
      "label": "是否为超级用户属性"
    },
    "ldap": {
      "desc": "使用 LDAP 作为认证数据源的认证器的配置项。"
    },
    "password_attribute": {
      "desc": "指示哪个属性用于表示用户密码。",
      "label": "密码属性"
    },
    "query_timeout": {
      "desc": "LDAP 查询的超时时间。",
      "label": "查询超时"
    }
  },
  "emqx_authn_mnesia_schema": {
    "builtin_db": {
      "desc": "使用内置数据库作为认证数据源的认证器的配置项。"
    },
    "user_id_type": {
      "desc": "指定用于客户端身份 ID 认证的字段。",
      "label": "账号类型"
    }
  },
  "emqx_authn_mongodb_schema": {
    "collection": {
      "desc": "存储认证数据的集合。",
      "label": "集合"
    },
    "filter": {
      "desc": "在查询中定义过滤条件的条件表达式。\n过滤器支持如下占位符：\n- <code>${username}</code>: 将在运行时被替换为客户端连接时使用的用户名\n- <code>${clientid}</code>: 将在运行时被替换为客户端连接时使用的客户端 ID",
      "label": "过滤器"
    },
    "is_superuser_field": {
      "desc": "定义用户是否具有超级用户权限的字段。",
      "label": "超级用户字段"
    },
    "password_hash_field": {
      "desc": "存储密码散列值字段。",
      "label": "密码散列字段"
    },
    "replica-set": {
      "desc": "使用 MongoDB (Replica Set) 作为认证数据源的认证器的配置项。"
    },
    "salt_field": {
      "desc": "用于存储盐值的字段。",
      "label": "盐值字段"
    },
    "sharded-cluster": {
      "desc": "使用 MongoDB (Sharded Cluster) 作为认证数据源的认证器的配置项。"
    },
    "single": {
      "desc": "使用 MongoDB (Standalone) 作为认证数据源的认证器的配置项。"
    }
  },
  "emqx_authn_mysql_schema": {
    "mysql": {
      "desc": "使用 MySQL 作为认证数据源的认证器的配置项。"
    },
    "query": {
      "desc": "用于查询密码散列等用于认证的数据的 SQL 语句。",
      "label": "查询 SQL"
    },
    "query_timeout": {
      "desc": "SQL 查询的超时时间。",
      "label": "查询超时"
    }
  },
  "emqx_authn_postgresql_schema": {
    "postgresql": {
      "desc": "使用 PostgreSQL 作为认证数据源的认证器的配置项。"
    },
    "query": {
      "desc": "用于查询密码散列等用于认证的数据的 SQL 语句。",
      "label": "查询 SQL"
    }
  },
  "emqx_authn_redis_schema": {
    "cluster": {
      "desc": "使用 Redis (Cluster) 作为认证数据源的认证器的配置项。"
    },
    "cmd": {
      "desc": "用于查询密码散列等用于认证的数据的 Redis 命令，目前仅支持 <code>HGET</code> 与 <code>HMGET</code>。",
      "label": "Redis 命令"
    },
    "sentinel": {
      "desc": "使用 Redis (Sentinel) 作为认证数据源的认证器的配置项。"
    },
    "single": {
      "desc": "使用 Redis (Standalone) 作为认证数据源的认证器的配置项。"
    }
  },
  "emqx_authn_schema": {
    "backend": {
      "desc": "后端类型。",
      "label": "后端类型"
    },
    "enable": {
      "desc": "设为 <code>true</code> 或 <code>false</code> 以禁用此认证数据源。",
      "label": "启用"
    },
    "failed": {
      "desc": "当前数据源执行查询失败次数。",
      "label": "查询失败次数"
    },
    "global_authentication": {
      "desc": "默认的 MQTT 监听器的全局认证配置。\n\n有关每个监听器的单独配置，请参阅监听器配置中的<code>authentication</code>。\n\n此选项可配置为：\n<ul>\n  <li><code>[]</code>: 默认值，允许 *所有* 登录</li>\n  <li>one: 例如 <code>{enable:true,backend:\"built_in_database\",mechanism=\"password_based\"}</code></li>\n  <li>chain: 结构体数组。</li>\n</ul>\n\n当配置了一个认证链时，登录凭据将按照配置的顺序检查后端，直到可以做出'允许'或'拒绝'的决定。\n\n如果在完全遍历认证链之后没有决定，登录将被拒绝。",
      "label": "全局认证"
    },
    "listener_authentication": {
      "desc": "每个监听器的认证覆盖。\n认证可以是一个单一的认证器实例，也可以是一个认证器链，表示为一个数组\n在对登录进行身份认证（用户名、客户端 ID 等）时，将按照配置的顺序检查认证器。",
      "label": "每个监听器的认证覆盖。"
    },
    "matched": {
      "desc": "当前数据源执行查询次数。",
      "label": "查询次数"
    },
    "mechanism": {
      "desc": "认证方式。",
      "label": "认证方式"
    },
    "metrics": {
      "desc": "认证器统计指标。",
      "label": "指标"
    },
    "metrics_failed": {
      "desc": "在当前认证器中找到需要的认证信息，并且返回认证失败的次数。",
      "label": "认证失败次数"
    },
    "metrics_nomatch": {
      "desc": "在当前认证器中没有找到需要的认证信息，忽略认证的次数。",
      "label": "忽略认证次数"
    },
    "metrics_rate": {
      "desc": "当前认证器执行速度，次/秒。",
      "label": "认证速度"
    },
    "metrics_rate_last5m": {
      "desc": "当前认证器在最近 5 分钟内平均执行速度，单位：次/秒。",
      "label": "近 5 分钟内平均认证速度"
    },
    "metrics_rate_max": {
      "desc": "当前认证器曾经达到的最大认证速度，单位：次/秒。",
      "label": "最大认证速度"
    },
    "metrics_success": {
      "desc": "在当前认证器中找到需要的认证信息，并且实例返回认证成功的次数。",
      "label": "认证成功次数"
    },
    "metrics_total": {
      "desc": "当前认证器执行认证的总次数。",
      "label": "认证总次数"
    },
    "node": {
      "desc": "节点名称。",
      "label": "节点名称"
    },
    "node_error": {
      "desc": "节点上的错误信息。",
      "label": "节点错误信息"
    },
    "node_metrics": {
      "desc": "每个节点上认证器的统计指标。",
      "label": "节点指标"
    },
    "node_status": {
      "desc": "每个节点上数据源的状态。",
      "label": "节点数据源状态"
    },
    "rate": {
      "desc": "当前数据源执行查询速度，单位：次/秒。",
      "label": "查询速度"
    },
    "rate_last5m": {
      "desc": "当前数据源在最近 5 分钟内平均执行速度，单位：次/秒。",
      "label": "近 5 分钟内平均查询速度"
    },
    "rate_max": {
      "desc": "当前认数据源曾经达到的最大查询速度，单位：次/秒。",
      "label": "最大查询速度"
    },
    "status": {
      "desc": "数据源状态。",
      "label": "数据源状态"
    },
    "success": {
      "desc": "当前数据源查询成功次数。",
      "label": "查询成功次数"
    }
  },
  "emqx_authn_user_import_api": {
    "authentication_id_import_users_post": {
      "desc": "为全局认证链上的指定认证器导入用户数据。",
      "label": "为全局认证链上的指定认证器导入用户数据"
    },
    "listeners_listener_id_authentication_id_import_users_post": {
      "desc": "为监听器认证链上的指定认证器导入用户数据。",
      "label": "为监听器认证链上的指定认证器导入用户数据"
    }
  },
  "emqx_authz_api_cache": {
    "authorization_cache_delete": {
      "desc": "清除集群中所有授权结果缓存。",
      "label": "清除授权结果缓存"
    }
  },
  "emqx_authz_api_mnesia": {
    "action": {
      "desc": "授权的动作 （发布/订阅/发布与订阅）",
      "label": "动作"
    },
    "clientid": {
      "desc": "客户端 ID",
      "label": "客户端 ID"
    },
    "fuzzy_clientid": {
      "desc": "使用字串匹配模糊搜索客户端 ID",
      "label": "客户端 ID 子串"
    },
    "fuzzy_username": {
      "desc": "使用字串匹配模糊搜索用户名",
      "label": "用户名字串"
    },
    "permission": {
      "desc": "对应的权限",
      "label": "权限"
    },
    "qos": {
      "desc": "被授权操作的 QoS",
      "label": "QoS"
    },
    "retain": {
      "desc": "被授权操作的保留标志",
      "label": "保留标志"
    },
    "rules_all_delete": {
      "desc": "删除 'all' 规则",
      "label": "删除 'all' 规则"
    },
    "rules_all_get": {
      "desc": "列出适用于所有客户端规则 （即 'all' 规则）。",
      "label": "列出适用于所有客户端规则"
    },
    "rules_all_post": {
      "desc": "创建或更新适用于所有客户端的规则（即 'all' 规则）。",
      "label": "创建或更新适用于所有客户端的规则"
    },
    "rules_delete": {
      "desc": "清除内置数据库中的所有类型（'users' 、'clients' 、'all'）的所有规则",
      "label": "清除内置数据库中的规则"
    },
    "topic": {
      "desc": "该条规则对应的主题",
      "label": "主题"
    },
    "user_clientid_delete": {
      "desc": "删除指定客户端的规则",
      "label": "删除指定客户端的规则"
    },
    "user_clientid_get": {
      "desc": "获取指定客户端的规则",
      "label": "获取指定客户端的规则"
    },
    "user_clientid_put": {
      "desc": "设置指定客户端的规则",
      "label": "设置指定客户端的规则"
    },
    "user_username_delete": {
      "desc": "删除指定用户名的规则",
      "label": "删除指定用户名的规则'"
    },
    "user_username_get": {
      "desc": "获取指定用户名规则",
      "label": "获取指定用户名的规则"
    },
    "user_username_put": {
      "desc": "设置指定用户名的规则",
      "label": "设置指定用户名的规则"
    },
    "username": {
      "desc": "用户名",
      "label": "用户名"
    },
    "users_clientid_get": {
      "desc": "显示客户端规则列表。",
      "label": "显示客户端的规则"
    },
    "users_clientid_post": {
      "desc": "为指定客户端添加规则。",
      "label": "为指定客户端添加规则'"
    },
    "users_username_get": {
      "desc": "显示用户名规则列表。",
      "label": "显示用户名规则"
    },
    "users_username_post": {
      "desc": "为指定的用户添加规则。",
      "label": "为指定的用户添加规则"
    }
  },
  "emqx_authz_api_settings": {
    "authorization_settings_get": {
      "desc": "获取授权配置"
    },
    "authorization_settings_put": {
      "desc": "更新授权配置"
    }
  },
  "emqx_authz_api_sources": {
    "authorization_sources_get": {
      "desc": "列出所有授权器。",
      "label": "列出所有授权器"
    },
    "authorization_sources_post": {
      "desc": "添加授权器",
      "label": "添加授权器"
    },
    "authorization_sources_type_delete": {
      "desc": "删除指定的授权器",
      "label": "删除指的授权器"
    },
    "authorization_sources_type_get": {
      "desc": "获取指定的授权器",
      "label": "获取指定的授权器"
    },
    "authorization_sources_type_move_post": {
      "desc": "更新授权器的优先执行顺序",
      "label": "更新授权器的执行顺序"
    },
    "authorization_sources_type_put": {
      "desc": "更新指定的授权器",
      "label": "更新指定的授权器"
    },
    "authorization_sources_type_status_get": {
      "desc": "获取指定授权器的状态",
      "label": "获取指定授权器的状态"
    },
    "source": {
      "desc": "授权器所使用的数据源。",
      "label": "数据源"
    },
    "source_config": {
      "desc": "数据源配置",
      "label": "数据源配置"
    },
    "source_type": {
      "desc": "授权期所使用的数据源类型。",
      "label": "数据源类型"
    },
    "sources": {
      "desc": "授权数据源",
      "label": "数据源"
    }
  },
  "emqx_authz_file_schema": {
    "file": {
      "desc": "使用 ACL 文件授权。",
      "label": "文件"
    },
    "path": {
      "desc": "包含 ACL 规则的文件路径。\n如果该文件在启动 EMQX 节点之前已经配置好，\n只要 EMQX 有读取权限，它可以放置在任何位置。\n即，EMQX 将把它视为只读。\n\n如果规则集是从 EMQX Dashboard 或 HTTP API 创建或更新的，\n将创建一个新文件并放置在 EMQX 的 data_dir 中的 authz 子目录下，\n旧文件将不再使用。",
      "label": "路径"
    }
  },
  "emqx_authz_http_schema": {
    "body": {
      "desc": "HTTP 请求体",
      "label": "请求体"
    },
    "headers": {
      "desc": "HTTP Headers 列表",
      "label": "请求头"
    },
    "headers_no_content_type": {
      "desc": "HTTP Headers 列表 (无 <code>content-type</code>) 。",
      "label": "请求头(无 content-type)"
    },
    "http_get": {
      "desc": "使用外部 HTTP 服务器授权(GET 请求)。",
      "label": "http_get"
    },
    "http_post": {
      "desc": "使用外部 HTTP 服务器授权(POST 请求)。",
      "label": "http_post"
    },
    "matched": {
      "desc": "请求命中次数。",
      "label": "已命中"
    },
    "method": {
      "desc": "HTTP 请求方法",
      "label": "请求方法"
    },
    "request_timeout": {
      "desc": "HTTP 请求超时。",
      "label": "请求超时"
    },
    "url": {
      "desc": "认证服务器地址",
      "label": "URL"
    }
  },
  "emqx_authz_ldap_schema": {
    "all_attribute": {
      "desc": "表示使用哪个属性来表示允许`发布`和`订阅`的主题列表。",
      "label": "所有属性"
    },
    "publish_attribute": {
      "desc": "表示使用哪个属性来表示允许`发布`的主题列表。",
      "label": "发布属性"
    },
    "query_timeout": {
      "desc": "LDAP 查询超时。",
      "label": "查询超时"
    },
    "subscribe_attribute": {
      "desc": "表示使用哪个属性来表示允许`订阅`的主题列表。",
      "label": "订阅属性"
    }
  },
  "emqx_authz_mnesia_schema": {
    "builtin_db": {
      "desc": "使用内置数据库 (mnesia) 进行授权。",
      "label": "内置数据库"
    }
  },
  "emqx_authz_mongodb_schema": {
    "collection": {
      "desc": "包含授权数据的 `MongoDB` 集合。",
      "label": "集合"
    },
    "filter": {
      "desc": "定义查询中过滤条件的条件表达式。\n过滤器支持以下占位符<br/>\n - <code>${username}</code>：在连接时将用客户端使用的 <code>用户名</code> 替换<br/>\n - <code>${clientid}</code>：在连接时将用客户端使用的 <code>客户端 ID</code> 替换",
      "label": "过滤器"
    },
    "mongo_rs": {
      "desc": "使用 MongoDB 授权（副本集模式）",
      "label": "mongo_rs"
    },
    "mongo_sharded": {
      "desc": "使用 MongoDB 授权（分片集群模式）。",
      "label": "mongo_sharded"
    },
    "mongo_single": {
      "desc": "使用 MongoDB 授权（单实例）。",
      "label": "mongo_single"
    }
  },
  "emqx_authz_mysql_schema": {
    "mysql": {
      "desc": "使用 MySQL 数据库进行授权。",
      "label": "mysql"
    },
    "query": {
      "desc": "用于检索授权数据的数据库查询。",
      "label": "查询"
    }
  },
  "emqx_authz_postgresql_schema": {
    "postgresql": {
      "desc": "使用 PostgreSQL 数据库进行授权。",
      "label": "postgresql"
    },
    "query": {
      "desc": "用于检索授权数据的数据库查询。",
      "label": "查询"
    }
  },
  "emqx_authz_redis_schema": {
    "cmd": {
      "desc": "用于检索授权数据的数据库查询。",
      "label": "命令"
    },
    "redis_cluster": {
      "desc": "使用 Redis 集群进行授权。",
      "label": "redis_cluster"
    },
    "redis_sentinel": {
      "desc": "使用 Redis Sentinel 进行授权。",
      "label": "redis_sentinel"
    },
    "redis_single": {
      "desc": "使用单个 Redis 实例进行授权。",
      "label": "redis_single"
    }
  },
  "emqx_authz_schema": {
    "allow": {
      "desc": "----",
      "label": "认证成功的次数"
    },
    "authorization": {
      "desc": "与客户端授权相关的配置。",
      "label": "授权"
    },
    "deny": {
      "desc": "----",
      "label": "认证失败的次数"
    },
    "enable": {
      "desc": "设置为 <code>true</code> 或 <code>false</code> 来禁用此 ACL 提供者",
      "label": "启用"
    },
    "failed": {
      "desc": "查询失败的次数",
      "label": "失败"
    },
    "matched": {
      "desc": "此资源被查询的次数",
      "label": "匹配"
    },
    "metrics": {
      "desc": "资源的指标",
      "label": "指标"
    },
    "metrics_total": {
      "desc": "触发授权规则的总次数。",
      "label": "授权规则触发的总次数"
    },
    "node": {
      "desc": "节点名称。",
      "label": "节点名称"
    },
    "node_error": {
      "desc": "节点上产生的错误。",
      "label": "节点产生的错误"
    },
    "node_metrics": {
      "desc": "每个节点上授权器的统计指标。",
      "label": "节点指标"
    },
    "node_status": {
      "desc": "每个节点上数据源的状态。",
      "label": "节点数据源状态"
    },
    "nomatch": {
      "desc": "没有匹配到任何授权规则的次数。",
      "label": "没有匹配到任何授权规则的次数"
    },
    "rate": {
      "desc": "命中速率，单位：次/秒。",
      "label": "速率"
    },
    "rate_last5m": {
      "desc": "5 分钟内平均命中速率，单位：次/秒。",
      "label": "5 分钟内速率"
    },
    "rate_max": {
      "desc": "最大命中速率，单位：次/秒。",
      "label": "最大速率"
    },
    "sources": {
      "desc": "<br/>\n授权（ACL）数据提供者的数组。\n它被设计为一个数组，而不是哈希映射，因此可以\n将源按顺序排列形成访问控制链。<br/>\n\n在授权 '发布' 或 '订阅' 操作时，配置的\n源会按顺序检查。在检查 ACL 源时，\n如果未找到客户端（通过用户名或客户端 ID 标识），\n则继续检查下一个源。一旦返回 '允许' 或 '拒绝' 决定，\n立即停止检查。<br/>\n\n如果在任何源中都未找到客户端，\n则应用 'authorization.no_match' 中配置的默认操作。<br/>\n\n注意：\n源元素由它们的 '类型' 标识。\n不允许配置两个或更多相同类型的源。",
      "label": "数据源"
    },
    "status": {
      "desc": "数据源状态。",
      "label": "数据源状态"
    },
    "success": {
      "desc": "请求成功次数。",
      "label": "成功"
    },
    "type": {
      "desc": "数据后端类型",
      "label": "type"
    }
  },
  "emqx_auto_subscribe_api": {
    "list_auto_subscribe_api": {
      "desc": "获取自动订阅主题列表",
      "label": "获取自动订阅主题列表"
    },
    "update_auto_subscribe_api": {
      "desc": "更新自动订阅主题列表",
      "label": "更新自动订阅主题"
    },
    "update_auto_subscribe_api_response409": {
      "desc": "超出自动订阅主题列表长度限制",
      "label": "超出自动订阅主题列表长度限制"
    }
  },
  "emqx_auto_subscribe_schema": {
    "auto_subscribe": {
      "desc": "设备成功登录后，通过预定义的订阅表示法自动为设备完成订阅。支持使用占位符。",
      "label": "自动订阅"
    },
    "nl": {
      "desc": "默认值为 0。\nMQTT v3.1.1：如果你订阅了自己发布的主题，你将收到所有自己发布的消息。\nMQTT v5：如果在订阅时将此选项设置为 1，服务器将不会将你发布的消息转发给你。",
      "label": "No Local"
    },
    "qos": {
      "desc": "默认值 0。消息服务质量。\n至多一次（0）\n至少一次（1）\n恰好一次（2）",
      "label": "QoS"
    },
    "rap": {
      "desc": "默认值为 0。此选项用于指定服务器在向客户端转发消息时是否保留 RETAIN 标记，而且此选项不影响保留消息中的 RETAIN 标记。因此，当选项 Retain As Publish 设置为 0 时，客户端将直接根据消息中的 RETAIN 标记来区分这是普通的转发消息还是保留消息，而不是判断此消息是否为订阅后首次收到的消息（转发的消息可能在保留消息之前发送，这取决于不同消息服务器的具体实现）。",
      "label": "Retain As Publish"
    },
    "rh": {
      "desc": "默认值为 0。此选项用于指定客户端建立订阅时，服务器是否向客户端转发保留的消息。\n当 Retain Handling 等于 0 时，只要客户端成功订阅，服务器就会发送保留消息。\n当 Retain Handling 等于 1 时，如果客户端成功订阅并且此前不存在此订阅，服务器发送保留消息。毕竟，有时客户端重新发起订阅只是为了改变 QoS，并不意味着它想再次接收保留的消息。\n当 Retain Handling 等于 2 时，即使客户端成功订阅，服务器也不会发送保留消息。",
      "label": "Retain Handling"
    },
    "topic": {
      "desc": "主题名称，支持占位符。例如：client/${clientid}/username/${username}/host/${host}/port/${port}\n为必填字段，且不能为空字符串。",
      "label": "主题"
    }
  },
  "emqx_bridge_api": {
    "desc_api1": {
      "desc": "列出所有数据桥接",
      "label": "列出所有数据桥接"
    },
    "desc_api2": {
      "desc": "通过类型和名字创建数据桥接",
      "label": "创建数据桥接"
    },
    "desc_api3": {
      "desc": "通过 Id 获取数据桥接",
      "label": "获取数据桥接"
    },
    "desc_api4": {
      "desc": "通过 Id 更新数据桥接",
      "label": "更新数据桥接"
    },
    "desc_api5": {
      "desc": "通过 Id 删除数据桥接",
      "label": "删除数据桥接"
    },
    "desc_api6": {
      "desc": "通过 Id 重置数据桥接的指标",
      "label": "重置数据桥接指标"
    },
    "desc_api7": {
      "desc": "停止或启用所有节点上的桥接",
      "label": "集群数据桥接操作"
    },
    "desc_api8": {
      "desc": "在某个节点上停止/重新启动数据桥接。",
      "label": "单节点数据桥接操作"
    },
    "desc_api9": {
      "desc": "通过给定的 ID 测试创建一个新的桥接。 <br/>\nID 的格式必须为 ’{type}:{name}”",
      "label": "测试桥接创建"
    },
    "desc_bridge_metrics": {
      "desc": "通过 Id 来获取桥接的指标信息",
      "label": "获取桥接的指标"
    },
    "desc_enable_bridge": {
      "desc": "启用或禁用所有节点上的桥接",
      "label": "是否启用集群内的桥接"
    },
    "desc_param_path_enable": {
      "desc": "是否启用桥接",
      "label": "启用桥接"
    },
    "desc_param_path_id": {
      "desc": "数据桥接 ID ， 格式为 {type}:{name}",
      "label": "数据桥接 ID"
    },
    "desc_param_path_node": {
      "desc": "节点名，比如 emqx@127.0.0.1",
      "label": "节点名"
    },
    "desc_param_path_operation_cluster": {
      "desc": "集群可用操作：停止、重新启动",
      "label": "集群可用操作"
    },
    "desc_param_path_operation_on_node": {
      "desc": "节点可用操作：停止、重新启动",
      "label": "节点可用操作"
    }
  },
  "emqx_bridge_azure_event_hub": {
    "actions": {
      "desc": "一个动作的配置项",
      "label": "动作配置"
    },
    "auth_sasl_password": {
      "desc": "用于连接 Azure Event Hub 的连接字符串。应为命名空间共享访问策略的 \"连接字符串-主键\"。",
      "label": "连接字符串"
    },
    "auth_username_password": {
      "desc": "基于用户名/密码进行认证",
      "label": "用户名/密码认证"
    },
    "buffer_mode": {
      "desc": "消息缓存模式。\n\n<code>memory</code>: 将所有消息缓存在内存中。如果 EMQX 节点重新启动，消息将丢失。\n<code>disk</code>: 将消息缓存在磁盘上，确保它们在 EMQX 节点重新启动时仍然存在。\n<code>hybrid</code>: 消息最初在内存中缓存。当它们达到一定限制时 (更多详细信息请参考 <code>segment_bytes</code> 配置)，它们会逐渐转移到磁盘上。与 <code>memory</code> 模式类似，如果 EMQX 节点重新启动，消息将丢失。",
      "label": "缓存模式"
    },
    "connect_timeout": {
      "desc": "TCP 连接建立的最大等待时间（包括如果已启用身份认证则包括身份认证时间）",
      "label": "连接超时"
    },
    "connector_type": {
      "desc": "连接器类型",
      "label": "连接器类型"
    },
    "desc_config": {
      "desc": "Azure Event Hubs 数据桥接配置项。",
      "label": "Azure Event Hubs 数据桥接配置项"
    },
    "desc_name": {
      "desc": "桥接名称，作为桥接的一个可读描述。",
      "label": "桥接名称"
    },
    "kafka_message_timestamp": {
      "desc": "要使用哪个时间戳。时间戳需为毫秒精度的 Unix 时间戳，可以采用字符串格式，例如 <code>1661326462115</code> 或 <code>'1661326462115'</code>。 当未找到此模板的所需数据字段，或者找到的数据不是有效的整数时，将使用当前系统时间戳。",
      "label": "消息时间戳"
    },
    "kafka_producer": {
      "desc": "Azure Event Hub 生产者配置。",
      "label": "Azure Event Hub 生产者"
    },
    "kafka_topic": {
      "desc": "----",
      "label": "Event Hub 名称"
    },
    "min_metadata_refresh_interval": {
      "desc": "客户端在刷新 Azure Event Hub Kafka 代理和主题元数据之前必须等待的最小时间间隔。设置太小的值可能会给 Azure Event Hub 增加额外的负载。",
      "label": "元数据刷新的最小时间间隔"
    },
    "producer_buffer": {
      "desc": "配置生产者消息缓冲区。\n\n告诉 Azure Event Hub 生产者，在 EMQX 需要发送的消息多于 Azure Event Hub 能够处理的消息时，或者 Azure Event Hub 宕机时，如何缓冲消息。",
      "label": "消息缓冲区"
    },
    "producer_kafka_ext_headers": {
      "desc": "请提供更多的 Azure Event Hub 标头键值对<br/>这里的键值对将与<code>kafka_headers</code>字段的值合并，然后发送到 Azure Event Hub。",
      "label": "额外的 Azure Event Hub 标头"
    },
    "producer_kafka_opts": {
      "desc": "Azure Event Hub 生产者配置",
      "label": "Azure Event Hub 生产者"
    },
    "producer_opts": {
      "desc": "本地的 MQTT 数据源和 Azure Event Hub 的桥接配置。",
      "label": "MQTT 桥接至 Azure Event Hub"
    },
    "socket_receive_buffer": {
      "desc": "对套接字接收缓冲区进行微调。默认值已经优化以提高吞吐量。",
      "label": "套接字接收缓冲区大小"
    },
    "socket_send_buffer": {
      "desc": "微调套接字发送缓冲区。默认值已调整为实现高吞吐量。",
      "label": "Socket Send Buffer Size"
    },
    "socket_tcp_keepalive": {
      "desc": "启用 Azure Event Hub 桥接连接的 TCP keepalive 功能。\n该值由三个以逗号分隔的数字组成，格式为 'Idle,Interval,Probes'\n - Idle: 连接在服务器开始发送 keepalive 探测之前必须处于空闲状态的秒数（Linux 默认值为 7200 秒）。\n - Interval: TCP keepalive 探测之间的秒数（Linux 默认值为 75 秒）。\n - Probes: 在放弃并终止连接之前，从另一端未获得响应时要发送的 TCP keepalive 探测的最大数量（Linux 默认值为 9 次）。\n例如 \"240,30,5\" 表示：在连接空闲 240 秒后发送 TCP 保活探测，每隔 30 秒发送一次，直到收到响应，如果连续丢失 5 个响应，连接应该被关闭。\n默认值： 'none'",
      "label": "TCP keepalive 选项"
    }
  "ssl_client_opts": {
    "desc": "用于 Azure Event Hub 客户端的 TLS/SSL 选项。",
    "label": "TLS/SSL 选项"
  },
  "sync_query_timeout": {
    "desc": "此参数定义同步查询的超时限制。仅当桥接查询模式配置为 'sync' 时适用。",
    "label": "同步查询超时"
  }
  },
  "emqx_bridge_cassandra": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "cql_template": {
      "desc": "CQL 模板",
      "label": "CQL 模板"
    },
    "desc_config": {
      "desc": "Cassandra 桥接配置",
      "label": "Cassandra 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 Cassandra。 <br/>\n注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    }
  },
  "emqx_bridge_cassandra_connector": {
    "keyspace": {
      "desc": "要连接到的 Keyspace 名称。",
      "label": "Keyspace"
    },
    "servers": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port][,Host2:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 Cassandra 默认端口 9042。",
      "label": "Servers"
    }
  },
  "emqx_bridge_clickhouse": {
    "batch_value_separator": {
      "desc": "默认为逗号 ','，适用于 VALUE 格式。您也可以使用其他分隔符， 请参考 [INSERT INTO 语句](https://clickhouse.com/docs/en/sql-reference/statements/insert-into)。",
      "label": "分隔符"
    },
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "Clickhouse 桥接配置",
      "label": "Clickhouse 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 Clickhouse。 <br/>\n注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "sql_template": {
      "desc": "可以使用 ${field} 占位符来引用消息与客户端上下文中的变量，请确保对应字段存在且数据格式符合预期。此处不支持 [SQL 预处理](https://docs.emqx.com/zh/enterprise/v5.0/data-integration/data-bridges.html#sql-预处理)。",
      "label": "SQL 模板"
    }
  },
  "emqx_bridge_clickhouse_connector": {
    "base_url": {
      "desc": "你想连接到的 Clickhouse 服务器的 HTTP URL（例如 http://myhostname:8123）。",
      "label": "服务器 URL"
    },
    "connect_timeout": {
      "desc": "连接 HTTP 服务器的超时时间。",
      "label": "连接超时"
    }
  },
  "emqx_bridge_dynamo": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "DynamoDB 桥接配置",
      "label": "DynamoDB 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 DynamoDB。 <br/>\n注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "template": {
      "desc": "模板, 默认为空，为空时将会将整个消息存入数据库",
      "label": "模板"
    }
  },
  "emqx_bridge_dynamo_connector": {
    "aws_access_key_id": {
      "desc": "DynamoDB 的访问 ID。",
      "label": "连接访问 ID"
    },
    "aws_secret_access_key": {
      "desc": "DynamoDB 的访问密钥。",
      "label": "连接访问密钥"
    },
    "table": {
      "desc": "DynamoDB 的表。",
      "label": "表"
    },
    "url": {
      "desc": "DynamoDB 的地址。",
      "label": "DynamoDB 地址"
    }
  },
  "emqx_bridge_gcp_pubsub": {
    "connect_timeout": {
      "desc": "连接 HTTP 服务器的超时时间。",
      "label": "连接超时"
    },
    "desc_config": {
      "desc": "GCP PubSub 桥接配置",
      "label": "GCP PubSub 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字，可读描述",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "桥接类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 GCP PubSub。 <br/>\n注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发到 GCP PubSub。",
      "label": "本地 Topic"
    },
    "max_retries": {
      "desc": "请求出错时的最大重试次数。",
      "label": "最大重试次数"
    },
    "payload_template": {
      "desc": "用于格式化外发信息的模板。 如果未定义，将以 JSON 格式发送所有可用的上下文。",
      "label": "HTTP 请求消息体模板"
    },
    "pipelining": {
      "desc": "正整数，设置最大可发送的异步 HTTP 请求数量。当设置为 1 时，表示每次发送完成 HTTP 请求后都需要等待服务器返回，再继续发送下一个请求。",
      "label": "HTTP 流水线"
    },
    "pool_size": {
      "desc": "连接池大小。",
      "label": "连接池大小"
    },
    "pubsub_topic": {
      "desc": "要发布消息的 GCP PubSub 主题。",
      "label": "GCP PubSub 主题"
    },
    "request_timeout": {
      "desc": "废弃的。在缓冲区设置中配置请求超时。",
      "label": "HTTP 请求超时"
    },
    "service_account_json": {
      "desc": "包含将与 PubSub 一起使用的 GCP 服务账户凭证的 JSON。\n当创建 GCP 服务账户时（如 https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount），可以选择下载 JSON 形式的凭证，然后在该配置项中使用。",
      "label": "GCP 服务账户凭证"
    }
  },
  "emqx_bridge_influxdb": {
    "config_enable": {
      "desc": "启用/禁用桥接。",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "InfluxDB 桥接配置。",
      "label": "InfluxDB 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名称。",
      "label": "桥接名称"
    },
    "desc_type": {
      "desc": "桥接类型。",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 InfluxDB。 <br/>\n注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发到 InfluxDB。",
      "label": "本地 Topic"
    },
    "write_syntax": {
      "desc": "使用 InfluxDB API Line Protocol 写入 InfluxDB 的数据，支持占位符<br/>\n参考 [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) 及\n[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) <br/>\nTLDR: <br/>\n\n```\n<measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]\n```\n注意，整形数值占位符后需要添加一个字符 `i` 类型标识。例如 `${payload.int_value}i`",
      "label": "写语句"
    }
  },
  "emqx_bridge_influxdb_connector": {
    "bucket": {
      "desc": "InfluxDB bucket 名称。",
      "label": "Bucket"
    },
    "database": {
      "desc": "InfluxDB 数据库。",
      "label": "数据库"
    },
    "influxdb_api_v1": {
      "desc": "InfluxDB HTTP API 协议。支持 Influxdb v1.8 以及之前的版本。",
      "label": "HTTP API 协议"
    },
    "influxdb_api_v2": {
      "desc": "InfluxDB HTTP API V2 协议。支持 Influxdb v2.0 以及之后的版本。",
      "label": "HTTP API V2 协议"
    },
    "org": {
      "desc": "InfluxDB 组织名称。",
      "label": "组织"
    },
    "password": {
      "desc": "InfluxDB 密码。",
      "label": "密码"
    },
    "precision": {
      "desc": "InfluxDB 时间精度。",
      "label": "时间精度"
    },
    "protocol": {
      "desc": "InfluxDB 协议。HTTP API 或 HTTP API V2。",
      "label": "协议"
    },
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 InfluxDB 默认端口 8086。",
      "label": "服务器地址"
    },
    "token": {
      "desc": "InfluxDB token。",
      "label": "Token"
    },
    "username": {
      "desc": "InfluxDB 用户名。",
      "label": "用户名"
    }
  },
  "emqx_bridge_iotdb": {
    "auth_basic": {
      "desc": "基本认证（basic auth）的参数。",
      "label": "基本认证(basic auth)"
    },
    "config_auth_basic_password": {
      "desc": "Basic auth 密码。类似 IoTDB REST 接口中的密码。",
      "label": "Basic auth 密码"
    },
    "config_auth_basic_username": {
      "desc": "Basic auth 用户名。类似 IoTDB REST 接口中的用户名。",
      "label": "Basic auth 用户名"
    },
    "config_authentication": {
      "desc": "认证信息",
      "label": "认证信息"
    },
    "config_base_url": {
      "desc": "IoTDB REST 服务的 URL。",
      "label": "REST 服务 URL"
    },
    "config_device_id": {
      "desc": "IoTDB 的设备 ID（DeviceID）。可以使用一个占位符。如果留空则 MQTT 消息体中必须有一个 `device_id` 字段，\n或者 EMQX 规则引擎的 SQL 必须输出一个 `device_id` 字段。",
      "label": "Device ID"
    },
    "config_enable": {
      "desc": "启用或禁用该桥接",
      "label": "启用或禁用"
    },
    "config_iotdb_version": {
      "desc": "IoTDB 版本。",
      "label": "IoTDB 版本"
    },
    "config_is_aligned": {
      "desc": "是否对齐时间序列。",
      "label": "对齐时间序列"
    },
    "config_max_retries": {
      "desc": "HTTP 请求的最大重试次数。",
      "label": "最大重试次数"
    },
    "config_request_timeout": {
      "desc": "HTTP 请求超时时间。",
      "label": "请求超时"
    },
    "desc_config": {
      "desc": "IoTDB 数据桥接配置",
      "label": "IoTDB 配置"
    },
    "desc_name": {
      "desc": "IoTDB 数据桥接名称。",
      "label": "桥接名称"
    }
  },
  "emqx_bridge_kafka": {
    "auth_gssapi_kerberos": {
      "desc": "使用 GSSAPI/Kerberos 认证。",
      "label": "GSSAPI/Kerberos"
    },
    "auth_kerberos_keytab_file": {
      "desc": "SASL GSSAPI 认证方法的 Kerberos keytab 文件。注意：该文件需要上传到 EMQX 服务器中，且运行 EMQX 服务的系统账户需要有读取权限。",
      "label": "Kerberos keytab 文件"
    },
    "auth_kerberos_principal": {
      "desc": "SASL GSSAPI 认证方法的 Kerberos principal，例如 <code>client_name@MY.KERBEROS.REALM.MYDOMAIN.COM</code>注意：这里使用的 realm 需要配置在 EMQX 服务器的 /etc/krb5.conf 中。",
      "label": "Kerberos Principal"
    },
    "auth_sasl_mechanism": {
      "desc": "SASL 认证方法名称。",
      "label": "认证方法"
    },
    "auth_sasl_password": {
      "desc": "SASL 认证的密码。",
      "label": "密码"
    },
    "auth_sasl_username": {
      "desc": "SASL 认证的用户名。",
      "label": "用户名"
    },
    "auth_username_password": {
      "desc": "基于用户名密码的认证。",
      "label": "用户名密码认证"
    },
    "authentication": {
      "desc": "认证参数。",
      "label": "认证"
    },
    "bootstrap_hosts": {
      "desc": "用逗号分隔的 <code>host[:port]</code> 主机列表。默认端口号为 9092。",
      "label": "主机列表"
    },
    "bridge_v2_type": {
      "desc": "数据桥接类型",
      "label": "数据桥接类型"
    },
    "buffer_memory_overload_protection": {
      "desc": "缓存模式是 <code>memory</code> 或 <code>hybrid</code> 时适用。当系统处于高内存压力时，从队列中丢弃旧的消息以减缓内存增长。内存压力值由配置项 <code>sysmon.os.sysmem_high_watermark</code> 决定。注意，该配置仅在 Linux 系统中有效。",
      "label": "内存过载保护"
    },
    "buffer_mode": {
      "desc": "消息缓存模式。\n<code>memory</code>: 所有的消息都缓存在内存里。如果 EMQX 服务重启，缓存的消息会丢失。\n<code>disk</code>: 缓存到磁盘上。EMQX 重启后会继续发送重启前未发送完成的消息。\n<code>hybrid</code>: 先将消息缓存在内存中，当内存中的消息堆积超过一定限制（配置项 <code>segment_bytes</code> 描述了该限制）后，后续的消息会缓存到磁盘上。与 <code>memory</code> 模式一样，如果 EMQX 服务重启，缓存的消息会丢失。",
      "label": "缓存模式"
    },
    "buffer_per_partition_limit": {
      "desc": "为每个 Kafka 分区设置的最大缓存字节数。当超过这个上限之后，老的消息会被丢弃，为新的消息腾出空间。",
      "label": "Kafka 分区缓存上限"
    },
    "buffer_segment_bytes": {
      "desc": "当缓存模式是 <code>disk</code> 或 <code>hybrid</code> 时适用。该配置用于指定缓存到磁盘上的文件的大小。",
      "label": "缓存文件大小"
    },
    "compression": {
      "desc": "压缩方法。",
      "label": "压缩"
    },
    "config_enable": {
      "desc": "启用（true）或停用该（false）Kafka 数据桥接。",
      "label": "启用或停用"
    },
    "connect_timeout": {
      "desc": "建立 TCP 连接时的最大等待时长（若启用认证，这个等待时长也包含完成认证所需时间）。",
      "label": "连接超时"
    },
    "consumer_kafka_opts": {
      "desc": "Kafka 消费者配置。",
      "label": "Kafka 消费者"
    },
    "consumer_kafka_topic": {
      "desc": "指定从哪个 Kafka 主题消费消息。",
      "label": "Kafka 主题"
    },
    "consumer_key_encoding_mode": {
      "desc": "通过 MQTT 转发之前，如何处理 Kafka 消息的 Key。<code>none</code> 使用 Kafka 消息中的 Key 原始值，不进行编码。  注意：在这种情况下，Key 必须是一个有效的 UTF-8 字符串。\n<code>base64</code> 对收到的密钥或值使用 base-64 编码。",
      "label": "Key 编码模式"
    },
    "consumer_max_batch_bytes": {
      "desc": "设置每次从 Kafka 拉取数据的字节数。如该配置小于 Kafka 消息的大小，可能会影响消费性能。",
      "label": "拉取字节数"
    },
    "consumer_max_rejoin_attempts": {
      "desc": "消费组成员允许重新加入小组的最大次数。如超过该配置次数后仍未能成功加入消费组，则会在等待一段时间后重试。",
      "label": "最大的重新加入尝试"
    },
    "consumer_mqtt_opts": {
      "desc": "本地 MQTT 消息转发。",
      "label": "MQTT 转发"
    },
    "consumer_mqtt_payload": {
      "desc": "用于转换收到的 Kafka 消息的模板。 默认情况下，它将使用 JSON 格式来序列化来自 Kafka 的所有字段。 这些字段包括：<code>headers</code>：一个包含字符串键值对的 JSON 对象。\n<code>key</code>：Kafka 消息的键（使用选择的编码方式编码）。\n<code>offset</code>：消息的偏移量。\n<code>topic</code>：Kafka 主题。\n<code>ts</code>: 消息的时间戳。\n<code>ts_type</code>：消息的时间戳类型，值可能是： <code>create</code>， <code>append</code> 或 <code>undefined</code>。\n<code>value</code>: Kafka 消息值（使用选择的编码方式编码）。",
      "label": "MQTT Payload Template"
    },
    "consumer_mqtt_qos": {
      "desc": "转发 MQTT 消息时使用的 QoS。",
      "label": "QoS"
    },
    "consumer_mqtt_topic": {
      "desc": "设置 Kafka 消息向哪个本地 MQTT 主题转发消息。",
      "label": "MQTT 主题"
    },
    "consumer_offset_commit_interval_seconds": {
      "desc": "指定 Kafka 消费组偏移量提交的时间间隔。",
      "label": "偏移提交间隔"
    },
    "consumer_offset_reset_policy": {
      "desc": "如不存在偏移量历史记录或历史记录失效，消费者应使用哪个偏移量开始消费。",
      "label": "偏移重置策略"
    },
    "consumer_opts": {
      "desc": "本地 MQTT 转发 和 Kafka 消费者配置。",
      "label": "MQTT 到 Kafka"
    },
    "consumer_topic_mapping": {
      "desc": "指定 Kafka 主题和 MQTT 主题之间的映射关系。 应至少包含一项。",
      "label": "主题映射关系"
    },
    "consumer_value_encoding_mode": {
      "desc": "通过 MQTT 转发之前，如何处理 Kafka 消息的 Value。<code>none</code> 使用 Kafka 消息中的 Value 原始值，不进行编码。  注意：在这种情况下，Value 必须是一个有效的 UTF-8 字符串。\n<code>base64</code> 对收到的 Value 使用 base-64 编码。",
      "label": "Value 编码模式"
    },
    "desc_config": {
      "desc": "一个 Kafka 生产者客户端的配置项",
      "label": "Kafka 生产者客户端配置"
    },
    "desc_name": {
      "desc": "桥接名字，可读描述",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "桥接类型",
      "label": "桥接类型"
    },
    "kafka_consumer": {
      "desc": "Kafka 消费者配置。",
      "label": "Kafka 消费者"
    },
    "kafka_message": {
      "desc": "用于生成 Kafka 消息的模版。",
      "label": "Kafka 消息模版"
    },
    "kafka_message_key": {
      "desc": "生成 Kafka 消息 Key 的模版。如果模版生成后为空值，则会使用 Kafka 的 <code>NULL</code> ，而非空字符串。",
      "label": "消息的 Key"
    },
    "kafka_message_timestamp": {
      "desc": "生成 Kafka 消息时间戳的模版。该时间必需是一个整型数值（可以是字符串格式）例如 <code>1661326462115</code> 或 <code>'1661326462115'</code>。当所需的输入字段不存在，或不是一个整型时，则会使用当前系统时间。",
      "label": "消息的时间戳"
    },
    "kafka_message_value": {
      "desc": "生成 Kafka 消息 Value 的模版。如果模版生成后为空值，则会使用 Kafka 的 <code>NULL</code>，而非空字符串。",
      "label": "消息的 Value"
    },
    "kafka_producer": {
      "desc": "Kafka 生产者配置。",
      "label": "Kafka 生产者"
    },
    "kafka_producer_action": {
      "desc": "Kafka 生产者动作",
      "label": "Kafka 生产者动作"
    },
    "kafka_topic": {
      "desc": "Kafka 主题名称",
      "label": "Kafka 主题名称"
    },
    "max_batch_bytes": {
      "desc": "最大消息批量字节数。大多数 Kafka 环境的默认最低值是 1 MB，EMQX 的默认值比 1 MB 更小是因为需要补偿 Kafka 消息编码所需要的额外字节（尤其是当每条消息都很小的情况下）。当单个消息的大小超过该限制时，它仍然会被发送，（相当于该批量中只有单个消息）。",
      "label": "最大批量字节数"
    },
    "max_inflight": {
      "desc": "设置 Kafka 生产者（每个分区一个）在收到 Kafka 的确认前最多发送多少个请求（批量）。调大这个值通常可以增加吞吐量，但是，当该值设置大于 1 时存在消息乱序的风险。",
      "label": "飞行窗口"
    },
    "metadata_request_timeout": {
      "desc": "刷新元数据时最大等待时长。",
      "label": "元数据请求超时"
    },
    "min_metadata_refresh_interval": {
      "desc": "刷新 Kafka broker 和 Kafka 主题元数据段最短时间间隔。设置太小可能会增加 Kafka 压力。",
      "label": "元数据刷新最小间隔"
    },
    "mqtt_topic": {
      "desc": "MQTT 主题数据源由桥接指定，或留空由规则动作指定。",
      "label": "源 MQTT 主题"
    },
    "partition_count_refresh_interval": {
      "desc": "配置 Kafka 刷新分区数量的时间间隔。\nEMQX 发现 Kafka 分区数量增加后，会开始按 <code>partition_strategy<code> 配置，把消息发送到新的分区中。",
      "label": "分区数量刷新间隔"
    },
    "partition_strategy": {
      "desc": "设置消息发布时应该如何选择 Kafka 分区。\n\n<code>random</code>: 为每个消息随机选择一个分区。\n<code>key_dispatch</code>: Hash Kafka message key to a partition number",
      "label": "分区选择策略"
    },
    "producer_buffer": {
      "desc": "配置消息缓存的相关参数。\n\n当 EMQX 需要发送的消息超过 Kafka 处理能力，或者当 Kafka 临时下线时，EMQX 内部会将消息缓存起来。",
      "label": "消息缓存"
    },
    "producer_kafka_opts": {
      "desc": "Kafka 生产者参数。",
      "label": "生产者参数"
    },
    "producer_opts": {
      "desc": "本地 MQTT 数据源和 Kafka 桥接的配置。",
      "label": "MQTT 到 Kafka"
    },
    "required_acks": {
      "desc": "设置 Kafka leader 在返回给 EMQX 确认之前需要等待多少个 follower 的确认。\n\n<code>all_isr</code>: 需要所有的在线复制者都确认。\n<code>leader_only</code>: 仅需要分区 leader 确认。\n<code>none</code>: 无需 Kafka 回复任何确认。",
      "label": "Kafka 确认数量"
    },
    "server_name_indication": {
      "desc": "TLS 握手的 Server Name Indication (SNI) 设置。<br/>\n- <code>auto</code>：客户端将使用 <code>\"servicebus.windows.net\"</code> 作为 SNI。<br/>\n- <code>disable</code>：如果您希望阻止客户端发送 SNI。<br/>\n- 其他字符串值将按原样发送。",
      "label": "SNI"
    },
    "socket_nodelay": {
      "desc": "设置‘true’让系统内核立即发送。否则当需要发送的内容很少时，可能会有一定延迟（默认 40 毫秒）。",
      "label": "是否关闭延迟发送"
    },
    "socket_opts": {
      "desc": "更多 Socket 参数设置。",
      "label": "Socket 参数"
    },
    "socket_receive_buffer": {
      "desc": "TCP socket 的收包缓存调优。默认值是针对高吞吐量的一个推荐值。",
      "label": "Socket 收包缓存大小"
    },
    "socket_send_buffer": {
      "desc": "TCP socket 的发送缓存调优。默认值是针对高吞吐量的一个推荐值。",
      "label": "Socket 发送缓存大小"
    },
    "socket_tcp_keepalive": {
      "desc": "为 Kafka 桥接连接启用 TCP keepalive。\n该值是3个由逗号分隔的数字，格式为 'Idle,Interval,Probes'。\n - Idle: 连接在服务器开始发送 keep-alive 探测（Linux 默认 7200）之前需要空闲的秒数。\n - Interval: TCP keep-alive 探测发送间隔的秒数（Linux 默认 75）。\n - Probes: 如果没有从另一端获得响应，在放弃并终止连接之前发送的 TCP keep-alive 探测的最大数量 （Linux 默认 9）。\n例如 \"240,30,5\" 表示： 在连接空闲 240 秒后发送 TCP keepalive 探测 ，并且每 30 秒发送一次探测，直到收到响应，如果连续错过 5 个响应，则应关闭连接。\n默认值： 'none'",
      "label": "TCP keepalive 选项"
    },
    "ssl_client_opts": {
      "desc": "Kafka 客户端的 TLS/SSL 选项",
      "label": "TLS/SSL 选项"
    },
    "sync_query_timeout": {
      "desc": "该参数定义同步查询的超时限制。仅当桥接查询模式配置为'sync'时才适用。",
      "label": "同步查询超时"
    }
  },
  "emqx_bridge_mqtt_schema": {
    "config": {
      "desc": "MQTT 数据桥接的配置。",
      "label": "配置"
    },
    "desc_name": {
      "desc": "桥接名字，桥接的可读描述",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "数据桥接的类型",
      "label": "桥接类型"
    }
  },
  "emqx_bridge_opents": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "OpenTSDB 桥接配置",
      "label": "OpenTSDB 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    }
  },
  "emqx_bridge_opents_connector": {
    "details": {
      "desc": "是否返回详细信息。",
      "label": "详细信息"
    },
    "server": {
      "desc": "服务器的地址。",
      "label": "服务器地址"
    },
    "summary": {
      "desc": "是否返回摘要信息。",
      "label": "摘要信息"
    }
  },
  "emqx_bridge_oracle": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "Oracle Database 桥接配置",
      "label": "Oracle Database 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 Oracle Database。 <br/>注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>主机名具有以下形式：`Host[:Port]`。<br/>如果未指定 `[:Port]`，则使用 Oracle Database 默认端口 1521。",
      "label": "服务器地址"
    },
    "service_name": {
      "desc": "Oracle Database 服务名称。",
      "label": "Oracle Database 服务名称"
    },
    "sid": {
      "desc": "Oracle Database Sid 名称",
      "label": "Oracle Database Sid"
    },
    "sql_template": {
      "desc": "SQL 模板。模板字符串可以包含消息元数据和有效载荷字段的占位符。占位符的插入不需要任何检查和特殊格式化，因此必须确保插入的数值格式化和转义正确。模板字符串可以包含占位符模板字符串可以包含消息元数据和有效载荷字段的占位符。这些占位符被插入所以必须确保插入的值的格式正确。因此，确保插入的值格式化和转义正确是非常重要的。模板字符串可以包含占位符模板字符串可以包含消息元数据和有效载荷字段的占位符。这些占位符被插入所以必须确保插入的值的格式正确。确保插入的值被正确地格式化和转义。",
      "label": "SQL 模板"
    }
  },
  "emqx_bridge_pgsql": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "PostgreSQL 桥接配置",
      "label": "PostgreSQL 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 PostgreSQL。 <br/>\n注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "sql_template": {
      "desc": "SQL 模板",
      "label": "SQL 模板"
    }
  },
  "emqx_bridge_pulsar": {
    "auth_basic": {
      "desc": "基本认证的参数。",
      "label": "基本认证参数"
    },
    "auth_basic_password": {
      "desc": "基本认证密码。",
      "label": "密码"
    },
    "auth_basic_username": {
      "desc": "基本认证用户名。",
      "label": "用户名"
    },
    "auth_token": {
      "desc": "令牌认证的参数。",
      "label": "Token auth params"
    },
    "auth_token_jwt": {
      "desc": "JWT 认证令牌。",
      "label": "JWT"
    },
    "authentication": {
      "desc": "认证参数。",
      "label": "认证"
    },
    "buffer_memory_overload_protection": {
      "desc": "缓存模式是 <code>memory</code> 或 <code>hybrid</code> 时适用。当系统处于高内存压力时，从队列中丢弃旧的消息以减缓内存增长。内存压力值由配置项 <code>sysmon.os.sysmem_high_watermark</code> 决定。注意，该配置仅在 Linux 系统中有效。",
      "label": "内存过载保护"
    },
    "buffer_mode": {
      "desc": "消息缓存模式。\n<code>memory</code>: 所有的消息都缓存在内存里。如果 EMQX 服务重启，缓存的消息会丢失。\n<code>disk</code>: 缓存到磁盘上。EMQX 重启后会继续发送重启前未发送完成的消息。\n<code>hybrid</code>: 先将消息缓存在内存中，当内存中的消息堆积超过一定限制（配置项 <code>segment_bytes</code> 描述了该限制）后，后续的消息会缓存到磁盘上。与 <code>memory</code> 模式一样，如果 EMQX 服务重启，缓存的消息会丢失。",
      "label": "缓存模式"
    },
    "buffer_per_partition_limit": {
      "desc": "为每个 Pulsar 分区设置的最大缓存字节数。当超过这个上限之后，老的消息会被丢弃，为新的消息腾出空间。",
      "label": "Pulsar 分区缓存上限"
    },
    "buffer_segment_bytes": {
      "desc": "当缓存模式是 <code>disk</code> 或 <code>hybrid</code> 时适用。该配置用于指定缓存到磁盘上的文件的大小。",
      "label": "缓存文件大小"
    },
    "config_enable": {
      "desc": "启用（true）或停用（false）该 Pulsar 数据桥接。",
      "label": "启用或停用"
    },
    "connect_timeout": {
      "desc": "建立 TCP 连接时的最大等待时长（若启用认证，这个等待时长也包含完成认证所需时间）。",
      "label": "连接超时时间"
    },
    "desc_name": {
      "desc": "桥接名字，可读描述",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "桥接类型",
      "label": "桥接类型"
    },
    "producer_batch_size": {
      "desc": "在一个 Pulsar 消息中批处理的单个请求的最大数量。",
      "label": "批量大小"
    },
    "producer_buffer": {
      "desc": "配置消息缓存的相关参数。\n\n当 EMQX 需要发送的消息超过 Pulsar 处理能力，或者当 Pulsar 临时下线时，EMQX 内部会将消息缓存起来。",
      "label": "消息缓存"
    },
    "producer_compression": {
      "desc": "压缩方法。",
      "label": "压缩"
    },
    "producer_key_template": {
      "desc": "生成 Pulsar 消息 Key 的模版。",
      "label": "消息的 Key"
    },
    "producer_local_topic": {
      "desc": "MQTT 主题数据源由桥接指定，或留空由规则动作指定。",
      "label": "源 MQTT 主题"
    },
    "producer_max_batch_bytes": {
      "desc": "最大消息批量字节数。大多数 Pulsar 环境的默认最低值是 5 MB，EMQX 的默认值比 5 MB 更小是因为需要补偿 Pulsar 消息编码所需要的额外字节（尤其是当每条消息都很小的情况下）。当单个消息的大小超过该限制时，它仍然会被发送，（相当于该批量中只有单个消息）。",
      "label": "最大批量字节数"
    },
    "producer_message_opts": {
      "desc": "用于生成 Pulsar 消息的模版。",
      "label": "Pulsar 消息模版"
    },
    "producer_pulsar_message": {
      "desc": "用于生成 Pulsar 消息的模版。",
      "label": "Pulsar 消息模版"
    },
    "producer_pulsar_topic": {
      "desc": "Pulsar 主题名称",
      "label": "Pulsar 主题名称"
    },
    "producer_retention_period": {
      "desc": "当没有连接到 Pulsar 代理时，信息将被缓冲的时间。 较长的时间意味着将使用更多的内存/磁盘",
      "label": "保留期"
    },
    "producer_send_buffer": {
      "desc": "TCP socket 的发送缓存调优。默认值是针对高吞吐量的一个推荐值。",
      "label": "Socket 发送缓存大小"
    },
    "producer_strategy": {
      "desc": "设置消息发布时应该如何选择 Pulsar 分区。\n\n<code>random</code>: 为每个消息随机选择一个分区。\n<code>roundrobin</code>: 依次为每条信息挑选可用的生产商。\n<code>key_dispatch</code>: 将一批信息中的第一条信息的 Pulsar 信息密钥哈希到一个分区编号。",
      "label": "分区选择策略"
    },
    "producer_sync_timeout": {
      "desc": "同步发布时，从 Pulsar 接收发送回执的最长等待时间。",
      "label": "同步发布超时"
    },
    "producer_value_template": {
      "desc": "生成 Pulsar 消息 Value 的模版。",
      "label": "消息的 Value"
    },
    "pulsar_producer_struct": {
      "desc": "Pulsar 桥接配置",
      "label": "Pulsar 桥接配置"
    },
    "servers": {
      "desc": "以逗号分隔的 <code>scheme://host[:port]</code> 格式的 Pulsar URL 列表，支持的 scheme 有 <code>pulsar://</code> （默认）和<code>pulsar+ssl://</code>。默认的端口是 6650。",
      "label": "服务员"
    }
  },
  "emqx_bridge_rabbitmq": {
    "config_enable": {
      "desc": "启用或禁用桥接",
      "label": "启用或禁用桥接"
    },
    "desc_config": {
      "desc": "RabbitMQ 桥接配置",
      "label": "RabbitMQ 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名称",
      "label": "桥接名称"
    },
    "desc_type": {
      "desc": "桥接类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "转发到 RabbitMQ 的消息 MQTT 主题或主题过滤器。对所有的 'PUBLISH' 消息，如果匹配到该配置的主题或主题过滤器时，\n注意：如果此桥接被用作规则的动作，同时又配置了 'local_topic'，那么这两份消息都会被转发到 RabbitMQ，这可能会导致消息重复。",
      "label": "MQTT 主题"
    }
  },
  "emqx_bridge_rabbitmq_connector": {
    "auto_reconnect": {
      "desc": "是否自动重连。",
      "label": "自动重连"
    },
    "delivery_mode": {
      "desc": "消息的投递模式。non_persistent(1) 表示非持久化消息，persistent(2) 表示持久化消息。",
      "label": "投递模式"
    },
    "exchange": {
      "desc": " RabbitMQ Exchange 名称。",
      "label": "Exchange"
    },
    "exchange_type": {
      "desc": "RabbitMQ Exchange 的类型（例如 direct，fanout，或 topic）。",
      "label": "Exchange 类型"
    },
    "heartbeat": {
      "desc": "发送心跳的间隔时间。",
      "label": "心跳"
    },
    "password": {
      "desc": "用于认证的 RabbitMQ 密码。",
      "label": "密码"
    },
    "payload_template": {
      "desc": "用于生成 RabbitMQ 消息的模版。模板中的占位符（例如 '${fields.sub_field}'）会被替换成消息的字段值。如果该留空，则表示所有的输入字段都会被转发到 RabbitMQ，与使用 '${.}' 作为占位符的效果等价。",
      "label": "消息模版"
    },
    "pool_size": {
      "desc": "连接池的大小。",
      "label": "连接池大小"
    },
    "port": {
      "desc": "RabbitMQ 服务器监听的端口号（默认为 5672）。",
      "label": "端口号"
    },
    "publish_confirmation_timeout": {
      "desc": "等待 RabbitMQ 确认消息发布的超时时间。",
      "label": "发布确认超时"
    },
    "routing_key": {
      "desc": "用于路由消息的 Routing Key。",
      "label": "Routing Key"
    },
    "server": {
      "desc": "RabbitMQ 服务器的主机名或 IP 地址（例如 localhost）。",
      "label": "服务器"
    },
    "timeout": {
      "desc": "连接超时时间。",
      "label": "连接超时"
    },
    "username": {
      "desc": "用于认证的 RabbitMQ 用户名。",
      "label": "用户名"
    },
    "virtual_host": {
      "desc": "RabbitMQ 虚拟主机的名称。",
      "label": "虚拟主机"
    },
    "wait_for_publish_confirmations": {
      "desc": "是否等待 RabbitMQ 确认消息发布。",
      "label": "等待发布确认"
    }
  },
  "emqx_bridge_rocketmq": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "RocketMQ 桥接配置",
      "label": "RocketMQ 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 RocketMQ。 <br/>\n注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "template": {
      "desc": "模板, 默认为空，为空时将会将整个消息转发给 RocketMQ。 <br/>\n            模板可以是任意带有占位符的合法字符串, 例如:<br/>            ${id}, ${username}, ${clientid}, ${timestamp}<br/>\n            {\"id\" : ${id}, \"username\" : ${username}}",
      "label": "模板"
    }
  },
  "emqx_bridge_rocketmq_connector": {
    "access_key": {
      "desc": "RocketMQ 服务器的 `accessKey`。",
      "label": "AccessKey"
    },
    "refresh_interval": {
      "desc": "RocketMQ 主题路由更新间隔。",
      "label": "主题路由更新间隔"
    },
    "secret_key": {
      "desc": "RocketMQ 服务器的 `secretKey`。",
      "label": "SecretKey"
    },
    "security_token": {
      "desc": "RocketMQ 服务器安全令牌",
      "label": "安全令牌"
    },
    "send_buffer": {
      "desc": "RocketMQ 驱动的套字节发送消息的缓冲区大小",
      "label": "发送消息的缓冲区大小"
    },
    "servers": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 RocketMQ 默认端口 9876。",
      "label": "服务器地址"
    },
    "sync_timeout": {
      "desc": "RocketMQ 驱动同步调用的超时时间。",
      "label": "同步调用超时时间"
    },
    "topic": {
      "desc": "RocketMQ 主题",
      "label": "RocketMQ 主题"
    }
  },
  "emqx_bridge_schema": {
    "bridges_mqtt": {
      "desc": "桥接到另一个 MQTT Broker 的 MQTT 数据桥接",
      "label": "MQTT 数据桥接"
    },
    "bridges_webhook": {
      "desc": "转发消息到 HTTP 服务器的 WebHook",
      "label": "WebHook"
    },
    "desc_bridges": {
      "desc": "MQTT 数据桥接配置",
      "label": "MQTT 数据桥接配置"
    },
    "desc_enable": {
      "desc": "启用/禁用数据桥接",
      "label": "启用/禁用数据桥接"
    },
    "desc_metrics": {
      "desc": "Bridge 计数",
      "label": "Bridge 计数"
    },
    "desc_node_metrics": {
      "desc": "节点的计数器",
      "label": "节点的计数器"
    },
    "desc_node_name": {
      "desc": "节点的名字",
      "label": "节点名字"
    },
    "desc_node_status": {
      "desc": "节点的状态",
      "label": "节点的状态"
    },
    "desc_status": {
      "desc": "Bridge 的连接状态<br/>\n- <code>connecting</code>: 启动时的初始状态。<br/>\n- <code>connected</code>: 桥接驱动健康检查正常。<br/>\n- <code>disconnected</code>: 当桥接无法通过健康检查。<br/>\n- <code>stopped</code>: 桥接处于停用状态。<br/>\n- <code>inconsistent</code>: 集群中有各节点汇报的状态不一致。",
      "label": "Bridge 状态"
    },
    "desc_status_reason": {
      "desc": "桥接连接失败的原因。",
      "label": "失败原因"
    },
    "metric_dropped": {
      "desc": "被丢弃的消息个数。",
      "label": "丢弃"
    },
    "metric_dropped_other": {
      "desc": "因为其他原因被丢弃的消息个数。",
      "label": "其他丢弃"
    },
    "metric_dropped_queue_full": {
      "desc": "因为队列已满被丢弃的消息个数。",
      "label": "队列已满被丢弃"
    },
    "metric_dropped_resource_not_found": {
      "desc": "因为资源不存在被丢弃的消息个数。",
      "label": "资源不存在被丢弃"
    },
    "metric_dropped_resource_stopped": {
      "desc": "因为资源已停用被丢弃的消息个数。",
      "label": "资源停用被丢弃"
    },
    "metric_inflight": {
      "desc": "已异步地发送但没有收到 ACK 的消息个数。",
      "label": "已发送未确认"
    },
    "metric_matched": {
      "desc": "Bridge 被匹配到（被请求）的次数。",
      "label": "匹配次数"
    },
    "metric_queuing": {
      "desc": "当前被缓存到磁盘队列的消息个数。",
      "label": "被缓存"
    },
    "metric_rate": {
      "desc": "执行操作的速率，次/秒",
      "label": "速率"
    },
    "metric_rate_last5m": {
      "desc": "5 分钟平均速率，次/秒",
      "label": "5 分钟平均速率"
    },
    "metric_rate_max": {
      "desc": "执行操作的最大速率，次/秒",
      "label": "执行操作的最大速率"
    },
    "metric_received": {
      "desc": "从远程系统收到的消息个数。",
      "label": "已接收"
    },
    "metric_retried": {
      "desc": "重试的次数。",
      "label": "已重试"
    },
    "metric_sent_failed": {
      "desc": "发送失败的消息个数。",
      "label": "发送失败"
    },
    "metric_sent_success": {
      "desc": "已经发送成功的消息个数。",
      "label": "发送成功"
    }
  },
  "emqx_bridge_sqlserver": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "Microsoft SQL Server 桥接配置",
      "label": "Microsoft SQL Server 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "driver": {
      "desc": "SQL Server Driver 名称",
      "label": "SQL Server Driver 名称"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 Microsoft SQL Server。 <br/>\n注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "sql_template": {
      "desc": "SQL 模板",
      "label": "SQL 模板"
    }
  },
  "emqx_bridge_sqlserver_connector": {
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 SQL Server 默认端口 1433。",
      "label": "服务器地址"
    }
  },
  "emqx_bridge_tdengine": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "TDengine 桥接配置",
      "label": "TDengine 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 TDengine。 <br/>\n注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "sql_template": {
      "desc": "SQL 模板",
      "label": "SQL 模板"
    }
  },
  "emqx_bridge_tdengine_connector": {
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 TDengine 默认端口 6041。",
      "label": "服务器地址"
    }
  },
  "emqx_bridge_v2_api": {
    "desc_api1": {
      "desc": "列出所有创建的数据桥接。",
      "label": "列出所有数据桥接"
    },
    "desc_api10": {
      "desc": "列出所有可用的动作类型。",
      "label": "列出动作类型"
    },
    "desc_api2": {
      "desc": "通过类型和名称创建一个新的数据桥接。",
      "label": "创建数据桥接"
    },
    "desc_api3": {
      "desc": "通过 id 获取一个数据桥接",
      "label": "获取数据桥接"
    },
    "desc_api4": {
      "desc": "通过 id 更新数据桥接",
      "label": "更新数据桥接"
    },
    "desc_api5": {
      "desc": "通过 id 删除数据桥接",
      "label": "删除数据桥接"
    },
    "desc_api6": {
      "desc": "通过 id 重置数据桥接指标。",
      "label": "重置数据桥接指标"
    },
    "desc_api7": {
      "desc": "启用集群中所有节点上的数据桥接。",
      "label": "集群数据桥接操作"
    },
    "desc_api8": {
      "desc": "在某个节点上启动数据桥接。",
      "label": "单节点数据桥接操作"
    },
    "desc_api9": {
      "desc": "测试创建一个新的数据桥接。",
      "label": "测试数据桥接创建"
    },
    "desc_bridge_metrics": {
      "desc": "通过 id 来获取数据桥接的指标信息。",
      "label": "获取数据桥接指标"
    },
    "desc_enable_bridge": {
      "desc": "启用或禁用集群内所有节点上的数据桥接。",
      "label": "是否启用集群内的数据桥接"
    },
    "desc_param_path_enable": {
      "desc": "是否启用该数据桥接。",
      "label": "启用数据桥接"
    },
    "desc_param_path_id": {
      "desc": "数据桥接 ID，格式必须为 {type}:{name}。",
      "label": "数据桥接 ID"
    },
    "desc_param_path_node": {
      "desc": "节点名称，例如： 'emqx@127.0.0.1'。",
      "label": "节点名称"
    },
    "desc_param_path_operation_cluster": {
      "desc": "集群可用操作：'启动'。",
      "label": "集群可用操作"
    },
    "desc_param_path_operation_on_node": {
      "desc": "节点可用操作：'启动'。",
      "label": "节点可用操作 "
    },
    "desc_qs_also_delete_dep_actions": {
      "desc": "是否级联删除依赖的动作。",
      "label": "级联删除依赖的动作?"
    }
  },
  "emqx_bridge_v2_schema": {
    "desc_bridges_v2": {
      "desc": "数据桥接的配置信息",
      "label": "数据桥接配置"
    }
  },
  "emqx_bridge_webhook_schema": {
    "config_body": {
      "desc": "HTTP 请求的正文。<br/>\n如果没有设置该字段，请求正文将是包含所有可用字段的 JSON object。<br/>\n如果该 webhook 是由于收到 MQTT 消息触发的，'所有可用字段' 将是 MQTT 消息的\n上下文信息；如果该 webhook 是由于规则触发的，'所有可用字段' 则为触发事件的上下文信息。<br/>\n允许使用带有变量的模板。",
      "label": "HTTP 请求正文"
    },
    "config_direction": {
      "desc": "已废弃，Bridge 的方向，必须是 egress",
      "label": "Bridge 方向"
    },
    "config_enable": {
      "desc": "启用/禁用数据桥接",
      "label": "启用/禁用数据桥接"
    },
    "config_headers": {
      "desc": "HTTP 请求的标头。<br/>\n允许使用带有变量的模板。",
      "label": "HTTP 请求标头"
    },
    "config_local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 HTTP 服务器。 <br/>\n注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发到 HTTP 服务器。",
      "label": "本地 Topic"
    },
    "config_max_retries": {
      "desc": "HTTP 请求失败最大重试次数",
      "label": "HTTP 请求重试次数"
    },
    "config_method": {
      "desc": "HTTP 请求的方法。 所有可用的方法包括：post、put、get、delete。<br/>\n允许使用带有变量的模板。",
      "label": "HTTP 请求方法"
    },
    "config_request_timeout": {
      "desc": "HTTP 请求超时",
      "label": "HTTP 请求超时"
    },
    "config_url": {
      "desc": "HTTP 数据桥接的 URL。<br/>\n路径中允许使用带变量的模板，但是 host， port 不允许使用变量模板。<br/>\n例如，<code> http://localhost:9901/${topic} </code> 是允许的，\n但是<code> http://${host}:9901/message </code>\n或 <code> http://localhost:${port}/message </code>\n不允许。",
      "label": "HTTP 数据桥接"
    },
    "desc_config": {
      "desc": "HTTP 数据桥接配置",
      "label": "HTTP 数据桥接配置"
    },
    "desc_name": {
      "desc": "Bridge 名字，Bridge 的可读描述",
      "label": "Bridge 名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "Bridge 类型"
    }
  },
  "emqx_coap_api": {
    "content_type": {
      "desc": "Payload 类型"
    },
    "message_id": {
      "desc": "消息 ID"
    },
    "method": {
      "desc": "请求 Method 类型"
    },
    "payload": {
      "desc": "Payload 内容"
    },
    "response_code": {
      "desc": "应答码"
    },
    "send_coap_request": {
      "desc": "发送 CoAP 消息到指定客户端"
    },
    "timeout": {
      "desc": "请求超时"
    },
    "token": {
      "desc": "消息 Token, 可以为空"
    }
  },
  "emqx_coap_schema": {
    "coap": {
      "desc": "CoAP 网关配置。\n该网关的实现基于 RFC-7252 和 https://core-wg.github.io/coap-pubsub/draft-ietf-core-pubsub.html"
    },
    "coap_connection_required": {
      "desc": "是否开启连接模式。\n连接模式是非标准协议的功能。它维护 CoAP 客户端上线、认证、和连接状态的保持"
    },
    "coap_heartbeat": {
      "desc": "CoAP 网关要求客户端的最小心跳间隔时间。\n当 <code>connection_required</code> 开启后，该参数用于检查客户端连接是否存活"
    },
    "coap_notify_type": {
      "desc": "投递给 CoAP 客户端的通知消息类型。当客户端 Observe 一个资源（或订阅某个主题）时，网关会向客户端推送新产生的消息。其消息类型可设置为：<br/>\n\n  - non: 不需要客户端返回确认消息;<br/>\n  - con: 需要客户端返回一个确认消息;<br/>\n  - qos: 取决于消息的 QoS 等级; QoS 0 会以 `non` 类型下发，QoS 1/2 会以 `con` 类型下发"
    },
    "coap_publish_qos": {
      "desc": "客户端发布请求的默认 QoS 等级。\n当 CoAP 客户端发起发布请求时，如果未携带 `qos` 参数则会使用该默认值。默认值可设置为：<br/>\n\n  - qos0、qos1、qos2: 设置为固定的 QoS 等级<br/>\n  - coap: 依据发布操作的 CoAP 报文类型来动态决定<br/>\n    * 当发布请求为 `non-confirmable` 类型时，取值为 qos0<br/>\n    * 当发布请求为 `confirmable` 类型时，取值为 qos1"
    },
    "coap_subscribe_qos": {
      "desc": "客户端订阅请求的默认 QoS 等级。\n当 CoAP 客户端发起订阅请求时，如果未携带 `qos` 参数则会使用该默认值。默认值可设置为：<br/>\n  - qos0、 qos1、qos2: 设置为固定的 QoS 等级<br/>\n  - coap: 依据订阅操作的 CoAP 报文类型来动态决定<br/>\n    * 当订阅请求为 `non-confirmable` 类型时，取值为 qos0<br/>\n    * 当订阅请求为 `confirmable` 类型时，取值为 qos1"
    }
  },
  "emqx_conf_schema": {
    "audit_file_handler_path": {
      "desc": "----",
      "label": "审计日志文件名"
    },
    "audit_handler_level": {
      "desc": "审计日志处理进程处理的日志级别。<br/>\n- 处理时间超过 3 秒的请求将被记录为 <code>warning</code> 级别日志。<br/>\n- HTTP 状态码在 200-300 之间的 GET 请求记录为<code>debug</code>日志。<br/>\n- HTTP 状态码在 200-300 之间的非 GET 请求记录为<code>info</code>日志。<br/>\n- HTTP 状态码在 300-400 之间的请求记录为<code>warning</code>日志。<br/>\n- HTTP 状态码在 400-500 之间的请求记录为<code>error</code>日志。<br/>\n- 默认为 info 级别。",
      "label": "日志级别"
    },
    "authorization": {
      "desc": "授权（ACL）。EMQX 支持完整的客户端访问控制（ACL）。",
      "label": "授权"
    },
    "cluster_autoclean": {
      "desc": "指定多久之后从集群中删除离线节点。",
      "label": "自动删除离线节点时间"
    },
    "cluster_autoheal": {
      "desc": "集群脑裂自动恢复机制开关。",
      "label": "节点脑裂自动修复机制"
    },
    "cluster_call_cleanup_interval": {
      "desc": "清理过期事务的时间间隔",
      "label": "清理间隔"
    },
    "cluster_call_max_history": {
      "desc": "集群间调用最多保留的历史记录数。只用于排错时查看。",
      "label": "最大历史记录"
    },
    "cluster_call_retry_interval": {
      "desc": "当集群间调用出错时，多长时间重试一次。",
      "label": "重试时间间隔"
    },
    "cluster_discovery_strategy": {
      "desc": "集群节点发现方式。可选值为:\n- manual: 使用 <code>emqx ctl cluster</code> 命令管理集群。<br/>\n- static: 配置静态节点。配置几个固定的节点，新节点通过连接固定节点中的某一个来加入集群。<br/>\n- dns: 使用 DNS A 记录的方式发现节点。<br/>\n- etcd: 使用 etcd 发现节点。<br/>\n- k8s: 使用 Kubernetes API 发现节点。",
      "label": "集群服务发现策略"
    },
    "cluster_dns_name": {
      "desc": "指定 DNS A 记录的名字。emqx 会通过访问这个 DNS A 记录来获取 IP 地址列表。\n当<code>cluster.discovery_strategy</code> 为 <code>dns</code> 时有效。",
      "label": "DNS 名称"
    },
    "cluster_dns_record_type": {
      "desc": "DNS 记录类型。",
      "label": "DNS 记录类型"
    },
    "cluster_etcd_node_ttl": {
      "desc": "指定 etcd 中节点信息的过期时间。\n当 cluster.discovery_strategy 为 etcd 时，此配置项才有效。",
      "label": "Etcd 节点过期时间"
    },
    "cluster_etcd_prefix": {
      "desc": "指定 etcd 路径的前缀。每个节点在 etcd 中都会创建一个路径:\nv2/keys/<prefix>/<cluster.name>/<node.name> <br/>\n当 cluster.discovery_strategy 为 etcd 时，此配置项才有效。",
      "label": "Etcd 路径前缀"
    },
    "cluster_etcd_server": {
      "desc": "指定 etcd 服务的地址。如有多个服务使用逗号 , 分隔。\n当 cluster.discovery_strategy 为 etcd 时，此配置项才有效。",
      "label": "Etcd 服务器地址"
    },
    "cluster_etcd_ssl": {
      "desc": "当使用 TLS 连接 etcd 时的配置选项。\n当 cluster.discovery_strategy 为 etcd 时，此配置项才有效。",
      "label": "Etcd SSL 选项"
    },
    "cluster_k8s_address_type": {
      "desc": "当使用 k8s 方式集群时，address_type 用来从 Kubernetes 接口的应答里获取什么形式的 Host 列表。\n指定 <code>cluster.k8s.address_type</code> 为 <code>ip</code>，则将从 Kubernetes 接口中获取集群中其他节点\n的 IP 地址。",
      "label": "K8s 地址类型"
    },
    "cluster_k8s_apiserver": {
      "desc": "指定 Kubernetes API Server。如有多个 Server 使用逗号 , 分隔。\n当 cluster.discovery_strategy 为 k8s 时，此配置项才有效。",
      "label": "K8s 服务地址"
    },
    "cluster_k8s_namespace": {
      "desc": "当使用 k8s 方式并且 cluster.k8s.address_type 指定为 dns 类型时，\n可设置 emqx 节点名的命名空间。与 cluster.k8s.suffix 一起使用用以拼接得到节点名列表。",
      "label": "K8s 命名空间"
    },
    "cluster_k8s_service_name": {
      "desc": "指定 Kubernetes 中 EMQX 的服务名。\n当 cluster.discovery_strategy 为 k8s 时，此配置项才有效。",
      "label": "K8s 服务别名"
    },
    "cluster_k8s_suffix": {
      "desc": "当使用 k8s 方式并且 cluster.k8s.address_type 指定为 dns 类型时，可设置 emqx 节点名的后缀。\n与 cluster.k8s.namespace 一起使用用以拼接得到节点名列表。",
      "label": "K8s 前缀"
    },
    "cluster_mcast_addr": {
      "desc": "指定多播 IPv4 地址。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播地址"
    },
    "cluster_mcast_buffer": {
      "desc": "用户级缓冲区的大小。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播用户级缓冲区"
    },
    "cluster_mcast_iface": {
      "desc": "指定节点发现服务需要绑定到本地 IP 地址。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播绑定地址"
    },
    "cluster_mcast_loop": {
      "desc": "设置多播的报文是否投递到本地回环地址。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播回环开关"
    },
    "cluster_mcast_ports": {
      "desc": "指定多播端口。如有多个端口使用逗号 , 分隔。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播端口"
    },
    "cluster_mcast_recbuf": {
      "desc": "接收数据报的内核级缓冲区的大小。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播接收数据缓冲区"
    },
    "cluster_mcast_sndbuf": {
      "desc": "外发数据报的内核级缓冲区的大小。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播发送缓存区"
    },
    "cluster_mcast_ttl": {
      "desc": "指定多播的 Time-To-Live 值。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播 TTL"
    },
    "cluster_name": {
      "desc": "EMQX 集群名称。每个集群都有一个唯一的名称。服务发现时会用于做路径的一部分。",
      "label": "集群名称"
    },
    "cluster_proto_dist": {
      "desc": "分布式 Erlang 集群协议类型。可选值为:<br/>\n- inet_tcp: 使用 IPv4 <br/>\n- inet_tls: 使用 TLS，需要配合 <code>etc/ssl_dist.conf</code> 一起使用。<br/>\n- inet6_tcp: IPv6 TCP <br/>\n- inet6_tls: IPv6 TLS， 与 <code>etc/ssl_dist.conf</code> 配合使用。",
      "label": "集群内部通信协议"
    },
    "cluster_static_seeds": {
      "desc": "集群中的 EMQX 节点名称列表，\n指定固定的节点列表，多个节点间使用逗号 , 分隔。\n当 cluster.discovery_strategy 为 static 时，此配置项才有效。\n适合于节点数量较少且固定的集群。",
      "label": "集群静态节点"
    },
    "common_handler_chars_limit": {
      "desc": "设置单个日志消息的最大长度。 如果超过此长度，则日志消息将被截断。最小可设置的长度为 100。\n注意：如果日志格式为 JSON，限制字符长度可能会导致截断不完整的 JSON 数据。",
      "label": "单条日志长度限制"
    },
    "common_handler_drop_mode_qlen": {
      "desc": "当缓冲的日志事件数大于此值时，新的日志事件将被丢弃。起到过载保护的功能。\n为了使过载保护算法正常工作必须要：<code> sync_mode_qlen =< drop_mode_qlen =< flush_qlen </code> 且 drop_mode_qlen > 1\n要禁用某些模式，请执行以下操作。\n- 如果 sync_mode_qlen 被设置为 0，所有的日志事件都被同步处理。也就是说，异步日志被禁用。\n- 如果 sync_mode_qlen 被设置为与 drop_mode_qlen 相同的值，同步模式被禁用。也就是说，处理程序总是以异步模式运行，除非调用 drop 或 flushing。\n- 如果 drop_mode_qlen 被设置为与 flush_qlen 相同的值，则 drop 模式被禁用，永远不会发生。",
      "label": "进入丢弃模式的队列长度"
    },
    "common_handler_enable": {
      "desc": "启用此日志处理进程。",
      "label": "启用日志处理进程"
    },
    "common_handler_flush_qlen": {
      "desc": "如果缓冲日志事件的数量增长大于此阈值，则会发生冲刷（删除）操作。 日志处理进程会丢弃缓冲的日志消息。\n来缓解自身不会由于内存瀑涨而影响其它业务进程。日志内容会提醒有多少事件被删除。",
      "label": "冲刷阈值"
    },
    "common_handler_formatter": {
      "desc": "选择日志格式类型。 <code>text</code> 用于纯文本，<code>json</code> 用于结构化日志记录。",
      "label": "日志格式类型"
    },
    "common_handler_level": {
      "desc": "当前日志处理进程的日志级别。\n默认为 warning 级别。",
      "label": "日志级别"
    },
    "common_handler_max_depth": {
      "desc": "Erlang 内部格式日志格式化和 Erlang 进程消息队列检查的最大深度。",
      "label": "最大深度"
    },
    "common_handler_single_line": {
      "desc": "如果设置为 true，则单行打印日志。 否则，日志消息可能跨越多行。",
      "label": "单行模式"
    },
    "common_handler_supervisor_reports": {
      "desc": "Supervisor 报告的类型。默认为 error 类型。<br/>\n  - <code>error</code>：仅记录 Erlang 进程中的错误。\n  - <code>progress</code>：除了 error 信息外，还需要记录进程启动的详细信息。",
      "label": "报告类型"
    },
    "common_handler_sync_mode_qlen": {
      "desc": "只要缓冲的日志事件的数量低于这个值，所有的日志事件都会被异步处理。\n这意味着，日志落地速度不会影响正常的业务进程，因为它们不需要等待日志处理进程的响应。\n如果消息队列的增长超过了这个值，处理程序开始同步处理日志事件。也就是说，发送事件的客户进程必须等待响应。\n当处理程序将消息队列减少到低于 sync_mode_qlen 阈值的水平时，异步操作就会恢复。\n默认为 100 条信息，当等待的日志事件大于 100 条时，就开始同步处理日志。",
      "label": "进入异步模式的队列长度"
    },
    "common_handler_time_offset": {
      "desc": "日志中的时间戳使用的时间偏移量。\n可选值为：\n  - <code>system</code>: 本地系统使用的时区偏移量\n  - <code>utc</code>: 0 时区的偏移量\n  - <code>+-[hh]:[mm]</code>: 自定义偏移量，比如 \"-02:00\" 或者 \"+00:00\"\n默认值为本地系统的时区偏移量：<code>system</code>。",
      "label": "时间偏移量"
    },
    "db_backend": {
      "desc": "配置后端数据库驱动，默认值为 <code>rlog</code> 它适用于大规模的集群。\n<code>mnesia</code> 是备选数据库，适合中小集群。",
      "label": "内置数据库"
    },
    "db_core_nodes": {
      "desc": "当前节点连接的核心节点列表。<br/>\n注意：该参数仅在设置<code>backend</code>时生效到 <code>rlog</code>\n并且设置<code>role</code>为<code>replicant</code>时生效。<br/>\n该值需要在手动或静态集群发现机制下设置。<br/>\n如果使用了自动集群发现机制（如<code>etcd</code>），则不需要设置该值。",
      "label": "数据库核心节点"
    },
    "db_default_bootstrap_batch_size": {
      "desc": "在引导过程中，从核心节点向复制节点推送的内置数据库表记录的批量数量。\n引导是在当新的复制节点添加到集群中或现有的复制节点重新连接到核心节点时发生的。\n增加此值可能会大大缩短复制节点的启动时间，特别是在 EMQX 集群互连网络延迟较高且 EMQX 内置数据库保存大量数据（例如订阅量很高时）的情况下\n默认值为 500。",
      "label": "默认引导批量大小"
    },
    "db_default_shard_transport": {
      "desc": "定义用于推送事务日志的默认传输。<br/>\n这可以在 <code>db.shard_transports</code> 中基于每个分片被覆盖。\n<code>gen_rpc</code> 使用 <code>gen_rpc</code> 库，\n<code>distr</code> 使用 Erlang 发行版。",
      "label": "事务日志传输默认协议"
    },
    "db_role": {
      "desc": "选择节点的角色。<br/>\n<code>core</code> 节点提供数据的持久性，并负责写入。建议将核心节点放置在不同的机架或不同的可用区。<br/>\n<code>repliant</code> 节点是临时工作节点。 从集群中删除它们，不影响数据库冗余<br/>\n建议复制节点多于核心节点。<br/>\n注意：该参数仅在设置<code>backend</code>时生效到 <code>rlog</code>。",
      "label": "数据库角色"
    },
    "db_rpc_module": {
      "desc": "集群间推送事务日志到复制节点使用的协议。",
      "label": "RPC 协议"
    },
    "db_shard_transports": {
      "desc": "允许为每个 shard 下的事务日志复制操作的传输方法进行调优。<br/>\n<code>gen_rpc</code> 使用 <code>gen_rpc</code> 库，\n<code>distr</code> 使用 Erlang 自带的 rpc 库。<br/>如果未指定，\n默认是使用 <code>db.default_shard_transport</code> 中设置的值。",
      "label": "事务日志传输协议"
    },
    "db_tlog_push_mode": {
      "desc": "同步模式下，核心节点等待复制节点的确认信息，然后再发送下一条事务日志。",
      "label": "Tlog 推送模式"
    },
    "desc_audit_log_handler": {
      "desc": "将日志时间输出到文件的审计日志处理进程。",
      "label": "审计日志处理进程"
    },
    "desc_authorization": {
      "desc": "授权相关",
      "label": "授权"
    },
    "desc_cluster": {
      "desc": "EMQX 节点可以组成一个集群，以提高总容量。<br/> 这里指定了节点之间如何连接。",
      "label": "集群"
    },
    "desc_cluster_call": {
      "desc": "集群调用功能的选项。",
      "label": "集群调用"
    },
    "desc_cluster_dns": {
      "desc": "DNS SRV 记录服务发现。",
      "label": "DNS SRV 记录服务发现"
    },
    "desc_cluster_etcd": {
      "desc": "使用 'etcd' 服务的服务发现。",
      "label": "'etcd' 服务的服务发现"
    },
    "desc_cluster_k8s": {
      "desc": "Kubernetes 服务发现。",
      "label": "Kubernetes 服务发现"
    },
    "desc_cluster_mcast": {
      "desc": "UDP 组播服务发现。",
      "label": "UDP 组播服务发现"
    },
    "desc_cluster_static": {
      "desc": "静态节点服务发现。新节点通过连接一个节点来加入集群。",
      "label": "静态节点服务发现"
    },
    "desc_console_handler": {
      "desc": "日志处理进程将日志事件打印到 EMQX 控制台。",
      "label": "Console Handler"
    },
    "desc_db": {
      "desc": "内置数据库的配置。",
      "label": "数据库"
    },
    "desc_log": {
      "desc": "EMQX 支持同时多个日志输出，一个控制台输出，和多个文件输出。\n默认情况下，EMQX 运行在容器中，或者在 'console' 或 'foreground' 模式下运行时，会输出到 控制台，否则输出到文件。",
      "label": "日志"
    },
    "desc_log_burst_limit": {
      "desc": "短时间内产生的大量日志事件可能会导致问题，例如：\n  - 日志文件变得非常大\n  - 日志文件轮换过快，有用信息被覆盖\n  - 对系统的整体性能影响\n\n日志突发限制功能可以暂时禁用日志记录以避免这些问题。",
      "label": "日志突发限制"
    },
    "desc_log_file_handler": {
      "desc": "日志处理进程将日志事件打印到文件。",
      "label": "文件日志处理进程"
    },
    "desc_log_overload_kill": {
      "desc": "日志过载终止，具有过载保护功能。当日志处理进程使用过多内存，或者缓存的日志消息过多时该功能被激活。<br/>\n检测到过载时，日志处理进程将终止，并在冷却期后重新启动。",
      "label": "日志过载保护"
    },
    "desc_log_rotation": {
      "desc": "默认情况下，日志存储在 `./log` 目录（用于从 zip 文件安装）或 `/var/log/emqx`（用于二进制安装）。<br/>\n这部分配置，控制每个日志处理进程保留的文件数量。",
      "label": "日志轮换"
    },
    "desc_node": {
      "desc": "节点名称、Cookie、配置文件、数据目录和 Erlang 虚拟机（BEAM）启动参数。",
      "label": "节点"
    },
    "desc_rpc": {
      "desc": "EMQX 使用 <code>gen_rpc</code> 库来实现跨节点通信。<br/>\n大多数情况下，默认的配置应该可以工作，但如果你需要做一些性能优化或者实验，可以尝试调整这些参数。",
      "label": "RPC"
    },
    "dist_buffer_size": {
      "desc": "Erlang 分布式缓冲区的繁忙阈值，单位是 KB。",
      "label": "Erlang 分布式缓冲区的繁忙阈值(KB)"
    },
    "log_audit_handler": {
      "desc": "审计日志文件处理进程",
      "label": "审计日志处理进程"
    },
    "log_burst_limit_enable": {
      "desc": "启用日志限流保护机制。",
      "label": "日志限流保护"
    },
    "log_burst_limit_max_count": {
      "desc": "在 `window_time` 间隔内处理的最大日志事件数。 达到限制后，将丢弃连续事件，直到 `window_time` 结束。",
      "label": "日志事件数"
    },
    "log_burst_limit_window_time": {
      "desc": "参考 <code>max_count</code>。",
      "label": "Window Time"
    },
    "log_file_handler_file": {
      "desc": "日志文件路径及名字。",
      "label": "日志文件名字"
    },
    "log_file_handler_max_size": {
      "desc": "此参数控制日志文件轮换。 `infinity` 意味着日志文件将无限增长，否则日志文件将在达到 `max_size`（以字节为单位）时进行轮换。\n与 rotation count 配合使用。如果 counter 为 10，则是 10 个文件轮换。",
      "label": "日志文件轮换大小"
    },
    "log_file_handlers": {
      "desc": "输出到文件的日志处理进程列表",
      "label": "File Handler"
    },
    "log_overload_kill_enable": {
      "desc": "日志处理进程过载时为保护自己节点其它的业务能正常，强制杀死日志处理进程。",
      "label": "日志处理进程过载保护"
    },
    "log_overload_kill_mem_size": {
      "desc": "日志处理进程允许使用的最大内存。",
      "label": "日志处理进程允许使用的最大内存"
    },
    "log_overload_kill_qlen": {
      "desc": "允许的最大队列长度。",
      "label": "最大队列长度"
    },
    "log_overload_kill_restart_after": {
      "desc": "处理进程停止后，会在该延迟时间后自动重新启动。除非该值设置为 <code>infinity</code>，这会阻止任何后续的重启。",
      "label": "处理进程重启延迟"
    },
    "log_rotation_count": {
      "desc": "轮换的最大日志文件数。",
      "label": "最大日志文件数"
    },
    "log_rotation_enable": {
      "desc": "启用日志轮换功能。启动后生成日志文件后缀会加上对应的索引数字，比如：log/emqx.log.1。\n系统会默认生成<code>*.siz/*.idx</code>用于记录日志位置，请不要手动修改这两个文件。",
      "label": "日志轮换"
    },
    "max_ets_tables": {
      "desc": "Erlang ETS 表的最大数量",
      "label": "Erlang 表的最大数量"
    },
    "max_ports": {
      "desc": "Erlang 系统同时存在的最大端口数。\n实际选择的最大值可能比设置的数字大得多。\n参考: https://www.erlang.org/doc/man/erl.html",
      "label": "Erlang 最大端口数"
    },
    "node_applications": {
      "desc": "当新 EMQX 加入集群时，应重启的 Erlang 应用程序的列表。",
      "label": "应用"
    },
    "node_backtrace_depth": {
      "desc": "错误信息中打印的最大堆栈层数",
      "label": "最大堆栈导数"
    },
    "node_broker_pool_size": {
      "desc": "emqx_broker 池中的工作进程数量。增加此值可能会因增强并行性而提高性能\n， 尤其在 EMQX 集群的互连网络延迟较高时。\n默认值为 Erlang 调度程序的数量（CPU 核心数）* 2。",
      "label": "节点 Broker 池大小"
    },
    "node_channel_cleanup_batch_size": {
      "desc": "通道清理批处理的大小。 如果 EMQX 集群互连网络延迟较高，\n减小此值以及增加 node.generic_pool_size\n可能会在大量客户端突然断开连接时提高性能。\n默认值为 100000。",
      "label": "节点通道清理批处理大小"
    },
    "node_cookie": {
      "desc": "分布式 Erlang 集群使用的 cookie 值。集群间保持一致",
      "label": "节点 Cookie"
    },
    "node_crash_dump_bytes": {
      "desc": "限制崩溃文件的大小，当崩溃时节点内存太大，\n如果为了保存现场，需要全部存到崩溃文件中，此处限制最多能保存多大的文件。\n如果超过此限制，崩溃转储将被截断。如果设置为 0，系统不会尝试写入崩溃转储文件。",
      "label": "崩溃文件最大大小"
    },
    "node_crash_dump_file": {
      "desc": "设置 Erlang crash_dump 文件的存储路径和文件名。",
      "label": "节点崩溃时的 Dump 文件"
    },
    "node_crash_dump_seconds": {
      "desc": "该配置给出了运行时系统允许花费的写入崩溃转储的秒数。当给定的秒数已经过去，运行时系统将被终止。<br/>\n- 如果设置为 0 秒，运行时会立即终止，不会尝试写入崩溃转储文件。<br/>\n- 如果设置为一个正数 S，节点会等待 S 秒来完成崩溃转储文件，然后用 SIGALRM 信号终止运行时系统。<br/>\n- 如果设置为一个负值导致运行时系统的终止等待无限期地直到崩溃转储文件已经完全写入。",
      "label": "保存崩溃文件最长时间"
    },
    "node_data_dir": {
      "desc": "节点数据存放目录，可能会自动创建的子目录如下：<br/>\n- `mnesia/<node_name>`。EMQX 的内置数据库目录。例如，`mnesia/emqx@127.0.0.1`。<br/>\n如果节点要被重新命名（例如，`emqx@10.0.1.1`）。旧目录应该首先被删除。<br/>\n- `configs`。在启动时生成的配置，以及集群/本地覆盖的配置。<br/>\n- `patches`: 热补丁文件将被放在这里。<br/>\n- `trace`: 日志跟踪文件。<br/>\n\n**注意**: 一个数据 dir 不能被两个或更多的 EMQX 节点同时使用。",
      "label": "节点数据目录"
    },
    "node_dist_net_ticktime": {
      "desc": "系统调优参数，此配置将覆盖 vm.args 文件里的 -kernel net_ticktime 参数。当一个节点持续无响应多久之后，认为其已经宕机并断开连接。",
      "label": "节点间心跳间隔"
    },
    "node_etc_dir": {
      "desc": "<code>etc</code> 存放目录",
      "label": "Etc 目录"
    },
    "node_generic_pool_size": {
      "desc": "emqx_pool 中的工作进程数。增加此值可能会通过增强并行性提高性能，\n特别是当 EMQX 集群互连网络延迟较高时。\n默认值为 Erlang 调度器（CPU 核心数）的数量。",
      "label": "节点通用池大小"
    },
    "node_global_gc_interval": {
      "desc": "系统调优参数，设置节点运行多久强制进行一次全局垃圾回收。禁用设置为 <code>disabled</code>。",
      "label": "全局垃圾回收"
    },
    "node_name": {
      "desc": "节点名。格式为 \\<name>@\\<host>。其中 <host> 可以是 IP 地址，也可以是 FQDN。\n详见 http://erlang.org/doc/reference_manual/distributed.html。",
      "label": "节点名"
    },
    "process_limit": {
      "desc": "Erlang 系统同时存在的最大进程数。\n实际选择的最大值可能比设置的数字大得多。\n参考: https://www.erlang.org/doc/man/erl.html",
      "label": "Erlang 最大进程数"
    },
    "rpc_async_batch_size": {
      "desc": "异步模式下，发送的批量消息的最大数量。",
      "label": "异步模式下的批量消息数量"
    },
    "rpc_authentication_timeout": {
      "desc": "远程节点认证的超时时间。",
      "label": "RPC 认证超时时间"
    },
    "rpc_cacertfile": {
      "desc": "验证 <code>rpc.certfile</code> 的 CA 证书文件的路径。<br/>\n注意：集群中所有节点的证书必须使用同一个 CA 签发。",
      "label": "RPC CA 证书文件"
    },
    "rpc_call_receive_timeout": {
      "desc": "同步 RPC 的回复超时时间。",
      "label": "RPC 调用接收超时时间"
    },
    "rpc_certfile": {
      "desc": "TLS 证书文件的路径，用于验证集群节点的身份。\n只有当 <code>rpc.driver</code> 设置为 <code>ssl</code> 时，此配置才会生效。",
      "label": "RPC 证书文件"
    },
    "rpc_connect_timeout": {
      "desc": "建立 RPC 连接的超时时间。",
      "label": "RPC 连接超时时间"
    },
    "rpc_driver": {
      "desc": "集群间通信使用的传输协议。",
      "label": "RPC 驱动"
    },
    "rpc_insecure_fallback": {
      "desc": "兼容旧的无鉴权模式",
      "label": "向后兼容旧的无鉴权模式"
    },
    "rpc_ipv6_only": {
      "desc": "此设置仅在 <code>rpc.listen_address</code> 被分配了一个 IPv6 地址时有效。\n如果设置为 <code>true</code>，RPC 客户端将仅使用 IPv6 进行连接。\n否则，即使服务器位于 IPv6 上，客户端也可能选择 IPv4。",
      "label": "仅使用 IPv6"
    },
    "rpc_keyfile": {
      "desc": "<code>rpc.certfile</code> 的私钥文件的路径。<br/>\n注意：此文件内容是私钥，所以需要设置权限为 600。",
      "label": "RPC 私钥文件"
    },
    "rpc_listen_address": {
      "desc": "指示 RPC 服务器监听的 IP 地址。例如，使用 <code>\"0.0.0.0\"</code> 表示 IPv4 或 <code>\"::\"</code> 表示 IPv6。",
      "label": "RPC 监听 IP 地址"
    },
    "rpc_mode": {
      "desc": "在 <code>sync</code> 模式下，发送端等待接收端的 ack 信号。",
      "label": "RPC 模式"
    },
    "rpc_port_discovery": {
      "desc": "<code>manual</code>: 通过 <code>tcp_server_port</code> 来发现端口。\n<br/><code>stateless</code>: 使用无状态的方式来发现端口，使用如下算法。如果节点名称是 <code>\nemqxN@127.0.0.1</code>, N 是一个数字，那么监听端口就是 5370 + N。",
      "label": "RPC 端口发现策略"
    },
    "rpc_send_timeout": {
      "desc": "发送 RPC 请求的超时时间。",
      "label": "RPC 发送超时时间"
    },
    "rpc_socket_buffer": {
      "desc": "TCP 调节参数。用户模式套接字缓冲区大小。",
      "label": "RPC 套接字缓冲区大小"
    },
    "rpc_socket_keepalive_count": {
      "desc": "keepalive 探测消息发送失败的次数，直到 RPC 连接被认为已经断开。",
      "label": "RPC Socket Keepalive 次数"
    },
    "rpc_socket_keepalive_idle": {
      "desc": "broker 之间的连接在最后一条消息发送后保持打开的时间。",
      "label": "RPC Socket Keepalive Idle"
    },
    "rpc_socket_keepalive_interval": {
      "desc": "keepalive 消息的间隔。",
      "label": "RPC Socket Keepalive 间隔"
    },
    "rpc_socket_recbuf": {
      "desc": "TCP 调节参数。TCP 接收缓冲区大小。",
      "label": "RPC 套接字接收缓冲区大小"
    },
    "rpc_socket_sndbuf": {
      "desc": "TCP 调节参数。TCP 发送缓冲区大小。",
      "label": "RPC 套接字发送缓冲区大小"
    },
    "rpc_ssl_server_port": {
      "desc": "RPC 本地服务使用的监听 SSL 端口。<br/>\n只有当 rpc.port_discovery 设置为 manual 且 <code> dirver </code> 设置为 <code>ssl</code>，\n此配置才会生效。",
      "label": "RPC SSL 服务监听端口"
    },
    "rpc_tcp_client_num": {
      "desc": "设置本节点与远程节点之间的 RPC 通信通道的最大数量。",
      "label": "RPC TCP 客户端数量"
    },
    "rpc_tcp_server_port": {
      "desc": "RPC 本地服务使用的 TCP 端口。<br/>\n只有当 rpc.port_discovery 设置为 manual 时，此配置才会生效。",
      "label": "RPC TCP 服务监听端口"
    }
  },
  "emqx_connector_api": {
    "desc_api1": {
      "desc": "列出所有创建的连接器。",
      "label": "列出所有连接器"
    },
    "desc_api2": {
      "desc": "通过类型和名称创建一个新的连接器。",
      "label": "创建连接器"
    },
    "desc_api3": {
      "desc": "通过 id 获取一个连接器。",
      "label": "获取连接器"
    },
    "desc_api4": {
      "desc": "通过 id 更新一个连接器。",
      "label": "更新连接器"
    },
    "desc_api5": {
      "desc": "通过 id 删除一个连接器。",
      "label": "删除连接器"
    },
    "desc_api6": {
      "desc": "通过 id 重置连接器指标。",
      "label": "重置连接器指标"
    },
    "desc_api7": {
      "desc": "在集群的所有节点上启动连接器。",
      "label": "集群连接器操作"
    },
    "desc_api8": {
      "desc": "在特定节点上启动连接器。",
      "label": "节点连接器操作"
    },
    "desc_api9": {
      "desc": "测试创建一个新的连接器。",
      "label": "测试连接器创建"
    },
    "desc_connector_metrics": {
      "desc": "通过 id 获取连接器指标。",
      "label": "获取连接器指标"
    },
    "desc_enable_connector": {
      "desc": "在集群的所有节点上启用或禁用连接器。",
      "label": "集群连接器启用"
    },
    "desc_param_path_enable": {
      "desc": "是否启用此连接器。",
      "label": "启用连接器"
    },
    "desc_param_path_id": {
      "desc": "连接器 id。必须是 {type}:{name} 的格式。",
      "label": "连接器 ID"
    },
    "desc_param_path_node": {
      "desc": "节点名称，例如 'emqx@127.0.0.1'。",
      "label": "节点名称"
    },
    "desc_param_path_operation_cluster": {
      "desc": "集群可用操作：'start'。",
      "label": "集群操作"
    },
    "desc_param_path_operation_on_node": {
      "desc": "节点可用操作：'start'。",
      "label": "节点操作"
    }
  },
  "emqx_connector_schema": {
    "connector_field": {
      "desc": "由动作指定的连接器名称，用于选择外部资源。",
      "label": "连接器"
    },
    "desc_connectors": {
      "desc": "用于连接到外部系统的连接器。",
      "label": "连接器"
    }
  },
  "emqx_connector_http": {
    "body": {
      "desc": "HTTP 请求报文主体。",
      "label": "HTTP 请求报文主体"
    },
    "connect_timeout": {
      "desc": "连接 HTTP 服务器的超时时间。",
      "label": "连接超时"
    },
    "enable_pipelining": {
      "desc": "正整数，设置最大可发送的异步 HTTP 请求数量。当设置为 1 时，表示每次发送完成 HTTP 请求后都需要等待服务器返回，再继续发送下一个请求。",
      "label": "HTTP 管道"
    },
    "headers": {
      "desc": "HTTP 头字段列表。",
      "label": "HTTP 头字段列表"
    },
    "max_retries": {
      "desc": "请求出错时的最大重试次数。",
      "label": "最大重试次数"
    },
    "method": {
      "desc": "HTTP 请求方法。",
      "label": "HTTP 请求方法"
    },
    "path": {
      "desc": "HTTP 请求路径。",
      "label": "HTTP 请求路径"
    },
    "pool_size": {
      "desc": "连接池大小。",
      "label": "连接池大小"
    },
    "pool_type": {
      "desc": "连接池的类型，可用类型有`random`, `hash`。",
      "label": "连接池类型"
    },
    "request": {
      "desc": "设置 HTTP 请求的参数。",
      "label": "HTTP 请求"
    },
    "request_timeout": {
      "desc": "HTTP 请求超时。",
      "label": "HTTP 请求超时"
    }
  },
  "emqx_connector_ldap": {
    "bind_dn": {
      "desc": "LDAP 绑定的 DN 的值",
      "label": "Bind DN"
    },
    "port": {
      "desc": "LDAP 端口",
      "label": "端口"
    },
    "timeout": {
      "desc": "LDAP 查询超时时间",
      "label": "超时时间"
    }
  },
  "emqx_connector_mongo": {
    "auth_source": {
      "desc": "与用户证书关联的数据库名称。",
      "label": "认证源"
    },
    "connect_timeout": {
      "desc": "超时重连的等待时间。",
      "label": "连接超时"
    },
    "desc_rs": {
      "desc": "配置 Replica Set",
      "label": "配置 Replica Set"
    },
    "desc_sharded": {
      "desc": "配置 Sharded Cluster",
      "label": "配置 Sharded Cluster"
    },
    "desc_single": {
      "desc": "配置 Single 模式",
      "label": "配置 Single 模式"
    },
    "desc_topology": {
      "desc": "配置 Topology",
      "label": "配置 Topology"
    },
    "heartbeat_period": {
      "desc": "控制驱动程序何时检查 MongoDB 部署的状态。指定检查的间隔时间，从上一次检查结束到下一次检查开始计算。如果连接数增加（例如，如果你增加池子的大小，就会发生这种情况），你可能也需要增加这个周期，以避免在 MongoDB 日志文件中创建太多的日志条目。",
      "label": "心跳期"
    },
    "local_threshold": {
      "desc": "在多个合适的 MongoDB 实例中进行选择的延迟窗口的大小。",
      "label": "本地阈值"
    },
    "max_overflow": {
      "desc": "最大溢出。",
      "label": "最大溢出"
    },
    "min_heartbeat_period": {
      "desc": "心跳间的最小间隙",
      "label": "最小心跳周期"
    },
    "overflow_check_period": {
      "desc": "检查是否有超过配置的工人的周期（\"溢出\"）。",
      "label": "溢出检查周期"
    },
    "overflow_ttl": {
      "desc": "当池内工人太多时，等待多久清除多余工人。",
      "label": "溢出 TTL"
    },
    "r_mode": {
      "desc": "读模式。",
      "label": "读模式"
    },
    "replica_set_name": {
      "desc": "副本集的名称。",
      "label": "副本集名称"
    },
    "rs_mongo_type": {
      "desc": "Replica set 模式。当 MongoDB 服务运行在 replica-set 模式下，该配置必须设置为 'rs'。",
      "label": "Replica set 模式"
    },
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 MongoDB 默认端口 27017。",
      "label": "服务器地址"
    },
    "server_selection_timeout": {
      "desc": "指定在抛出异常之前为服务器选择阻断多长时间。",
      "label": "服务器选择超时"
    },
    "servers": {
      "desc": "集群将要连接的节点列表。 节点之间用逗号分隔，如：`Node[,Node].`\n每个节点的配置为：将要连接的 IPv4 或 IPv6 地址或主机名。\n主机名具有以下形式：`Host[:Port]`。\n如果未指定 `[:Port]`，则使用 MongoDB 默认端口 27017。",
      "label": "服务器列表"
    },
    "sharded_mongo_type": {
      "desc": "Sharded cluster 模式。当 MongoDB 服务运行在 sharded 模式下，该配置必须设置为 'sharded'。",
      "label": "Sharded cluster 模式"
    },
    "single_mongo_type": {
      "desc": "Standalone 模式。当 MongoDB 服务运行在 standalone 模式下，该配置必须设置为 'single'。",
      "label": "Standalone 模式"
    },
    "socket_timeout": {
      "desc": "在尝试超时之前，在套接字上尝试发送或接收的持续时间。",
      "label": "套接字操作超时"
    },
    "srv_record": {
      "desc": "使用 DNS SRV 记录。",
      "label": "SRV 记录"
    },
    "w_mode": {
      "desc": "写模式。",
      "label": "写模式"
    },
    "wait_queue_timeout": {
      "desc": "工作者等待连接可用的最长时间。",
      "label": "等待队列超时"
    }
  },
  "emqx_connector_mqtt": {
    "name": {
      "desc": "连接器名称，人类可读的连接器描述。",
      "label": "连接器名称"
    },
    "num_of_bridges": {
      "desc": "当前使用此连接器的网桥数量。",
      "label": "网桥数量"
    },
    "type": {
      "desc": "连接器类型。",
      "label": "连接器类型"
    }
  },
  "emqx_connector_mqtt_schema": {
    "bridge_mode": {
      "desc": "是否启用数据桥接 Mode。\n注意：此设置只针对 MQTT 协议版本 < 5.0 有效，并且需要远程 MQTT Broker 支持数据桥接 Mode。\n如果设置为 true ，桥接会告诉远端服务器当前连接是一个桥接而不是一个普通的客户端。\n这意味着消息回环检测会更加高效，并且远端服务器收到的保留消息的标志位会透传给本地。",
      "label": "Bridge 模式"
    },
    "clean_start": {
      "desc": "与 ingress MQTT 桥的远程服务器重连时是否清除老的 MQTT 会话。",
      "label": "清除会话"
    },
    "clientid_prefix": {
      "desc": "可选的前缀，用于在出口网桥使用的 clientid 前加上前缀。",
      "label": "客户 ID 前缀"
    },
    "egress_desc": {
      "desc": "出口配置定义了该桥接如何将消息从本地 Broker 转发到远程 Broker。\n以下字段中允许使用带有变量的模板：'remote.topic', 'local.qos', 'local.retain', 'local.payload'。<br/>\n注意：如果此桥接被用作规则的动作，并且配置了 'local.topic'，则从规则输出的数据以及匹配到 'local.topic' 的 MQTT 消息都会被转发。",
      "label": "出方向配置"
    },
    "egress_local": {
      "desc": "如何从本地 Broker 接收消息相关的配置。",
      "label": "本地配置"
    },
    "egress_local_topic": {
      "desc": "要转发到远程 broker 的本地主题",
      "label": "本地主题"
    },
    "egress_remote": {
      "desc": "发送消息到远程 Broker 相关的配置。",
      "label": "远程配置"
    },
    "egress_remote_qos": {
      "desc": "待发送 MQTT 消息的 QoS。<br/>\n允许使用带有变量的模板。",
      "label": "远程 QoS"
    },
    "egress_remote_topic": {
      "desc": "转发到远程 broker 的哪个 topic。<br/>\n允许使用带有变量的模板。",
      "label": "远程主题"
    },
    "ingress_desc": {
      "desc": "入口配置定义了该桥接如何从远程 MQTT Broker 接收消息，然后将消息发送到本地 Broker。<br/>\n        以下字段中允许使用带有变量的模板：'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'。<br/>\n        注意：如果此桥接被用作规则的输入，并且配置了 'local.topic'，则从远程代理获取的消息将同时被发送到 'local.topic' 和规则。",
      "label": "入方向配置"
    },
    "ingress_local": {
      "desc": "发送消息到本地 Broker 相关的配置。",
      "label": "本地配置"
    },
    "ingress_local_qos": {
      "desc": "待发送 MQTT 消息的 QoS。<br/>\n允许使用带有变量的模板。",
      "label": "本地 QoS"
    },
    "ingress_local_topic": {
      "desc": "向本地 broker 的哪个 topic 发送消息。<br/>\n允许使用带有变量的模板。",
      "label": "本地主题"
    },
    "ingress_remote": {
      "desc": "订阅远程 Broker 相关的配置。",
      "label": "远程配置"
    },
    "ingress_remote_qos": {
      "desc": "订阅远程 borker 时要使用的 QoS 级别",
      "label": "远程 QoS"
    },
    "ingress_remote_topic": {
      "desc": "从远程 broker 的哪个 topic 接收消息",
      "label": "远程主题"
    },
    "max_inflight": {
      "desc": "MQTT 协议的最大飞行（已发送但未确认）消息",
      "label": "最大飞行消息"
    },
    "mode": {
      "desc": "MQTT 桥的模式。 <br/>\n\ncluster_shareload：在 emqx 集群的每个节点上创建一个 MQTT 连接。<br/>\n在“cluster_shareload”模式下，来自远程代理的传入负载通过共享订阅的方式接收。<br/>\n请注意，<code>clientid</code> 以节点名称为后缀，这是为了避免不同节点之间的 <code> clientid</code> 冲突。\n而且对于入口连接的 <code>remote.topic</code>，我们只能使用共享订阅主题过滤器。",
      "label": "MQTT 桥接模式"
    },
    "password": {
      "desc": "MQTT 协议的密码",
      "label": "密码"
    },
    "payload": {
      "desc": "要发送的 MQTT 消息的负载。<br/>\n允许使用带有变量的模板。",
      "label": "消息负载"
    },
    "proto_ver": {
      "desc": "MQTT 协议版本",
      "label": "协议版本"
    },
    "retain": {
      "desc": "要发送的 MQTT 消息的“保留”标志。<br/>\n允许使用带有变量的模板。",
      "label": "保留消息标志"
    },
    "server": {
      "desc": "远程 MQTT Broker 的主机和端口。",
      "label": "Broker 主机和端口"
    },
    "server_configs": {
      "desc": "服务器相关的配置。",
      "label": "服务配置。"
    },
    "username": {
      "desc": "MQTT 协议的用户名",
      "label": "用户名"
    }
  },
  "emqx_connector_mysql": {
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 MySQL 默认端口 3306。",
      "label": "服务器地址"
    }
  },
  "emqx_connector_pgsql": {
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 PostgreSQL 默认端口 5432。",
      "label": "服务器地址"
    }
  },
  "emqx_connector_redis": {
    "cluster": {
      "desc": "集群模式。当 Redis 服务运行在集群模式下，该配置必须设置为 'cluster'。",
      "label": "集群模式"
    },
    "database": {
      "desc": "Redis 数据库 ID。",
      "label": "数据库 ID"
    },
    "sentinel": {
      "desc": "哨兵模式。当 Redis 服务运行在哨兵模式下，该配置必须设置为 'sentinel'。",
      "label": "哨兵模式"
    },
    "sentinel_desc": {
      "desc": "Redis 哨兵模式下的集群名称。",
      "label": "集群名称"
    },
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 Redis 默认端口 6379。",
      "label": "服务器地址"
    },
    "servers": {
      "desc": "集群将要连接的节点列表。 节点之间用逗号分隔，如：`Node[,Node].`\n每个节点的配置为：将要连接的 IPv4 或 IPv6 地址或主机名。\n主机名具有以下形式：`Host[:Port]`。\n如果未指定 `[:Port]`，则使用 Redis 默认端口 6379。",
      "label": "服务器列表"
    },
    "single": {
      "desc": "单机模式。当 Redis 服务运行在单机模式下，该配置必须设置为 'single'。",
      "label": "单机模式"
    }
  },
  "emqx_connector_schema_lib": {
    "auto_reconnect": {
      "desc": "已弃用。自动重连数据库。",
      "label": "已弃用。自动重连数据库"
    },
    "database_desc": {
      "desc": "数据库名字。",
      "label": "数据库名字"
    },
    "password": {
      "desc": "内部数据库密码。",
      "label": "密码"
    },
    "pool_size": {
      "desc": "桥接远端服务时使用的连接池大小。",
      "label": "连接池大小"
    },
    "prepare_statement": {
      "desc": "SQL 预处理语句列表。",
      "label": "SQL 预处理语句列表"
    },
    "ssl": {
      "desc": "启用 SSL 连接。",
      "label": "启用 SSL"
    },
    "username": {
      "desc": "内部数据库的用户名。",
      "label": "用户名"
    }
  },
  "emqx_dashboard_api": {
    "backend": {
      "desc": "用户帐号来源"
    },
    "backend_name": {
      "desc": "----",
      "label": "后端名称"
    },
    "backend_not_found": {
      "desc": "操作失败。后端不存在"
    },
    "change_pwd_api": {
      "desc": "更改 Dashboard 用户密码",
      "label": "更改 Dashboard 用户密码"
    },
    "create_user_api": {
      "desc": "创建 Dashboard 用户",
      "label": "创建 Dashboard 用户"
    },
    "create_user_api_success": {
      "desc": "创建 Dashboard 用户成功",
      "label": "创建 Dashboard 用户成功"
    },
    "delete_backend": {
      "desc": "删除一个后端",
      "label": "删除后端"
    },
    "delete_user_api": {
      "desc": "删除 Dashboard 用户",
      "label": "删除 Dashboard 用户"
    },
    "get_backend": {
      "desc": "获取一个后端的详细信息",
      "label": "后端详情"
    },
    "get_sso": {
      "desc": "列出所有 SSO 后端",
      "label": "SSO 后端"
    },
    "last_error": {
      "desc": "该后端的最后错误",
      "label": "最后错误"
    },
    "license": {
      "desc": "EMQX License 类型。可为 opensource 或 enterprise"
    },
    "list_running": {
      "desc": "列出所有运行中的 SSO 后端",
      "label": "运行中的后端"
    },
    "list_users_api": {
      "desc": "Dashboard 用户列表",
      "label": "Dashboard 用户列表"
    },
    "login": {
      "desc": "----",
      "label": "获取 Dashboard 认证令牌。"
    },
    "login_api": {
      "desc": "登录成功后返回 Dashboard 认证 Token。",
      "label": "登录 Dashboard"
    },
    "login_failed401": {
      "desc": "登录失败。用户名或密码错误"
    },
    "login_failed_response400": {
      "desc": "登录失败。用户名或密码错误"
    },
    "login_success": {
      "desc": "Dashboard 登录成功"
    },
    "logout_api": {
      "desc": "Dashboard 用户退出登录",
      "label": "Dashboard 用户退出登录"
    },
    "new_pwd": {
      "desc": "新密码"
    },
    "old_pwd": {
      "desc": "旧密码"
    },
    "password": {
      "desc": "Dashboard 密码"
    },
    "redirect": {
      "desc": "重定向到 IDP SSO 登录页面"
    },
    "role": {
      "desc": "用户角色"
    },
    "running": {
      "desc": "后端是否正在运行",
      "label": "运行中"
    },
    "saml_sso_acs": {
      "desc": "SAML SSO ACS URL"
    },
    "sp_saml_metadata": {
      "desc": "SP SAML 元数据"
    },
    "token": {
      "desc": "Dashboard 认证 Token"
    },
    "update_backend": {
      "desc": "----",
      "label": "更新后端"
    },
    "update_user_api": {
      "desc": "更新 Dashboard 用户备注",
      "label": "更新 Dashboard 用户备注"
    },
    "update_user_api200": {
      "desc": "更新 Dashboard 用户成功"
    },
    "user_description": {
      "desc": "Dashboard 用户备注"
    },
    "username": {
      "desc": "Dashboard 用户名"
    },
    "users_api404": {
      "desc": "Dashboard 用户不存在"
    },
    "version": {
      "desc": "EMQX 版本"
    }
  },
  "emqx_dashboard_error_code_api": {
    "error_codes": {
      "desc": "API 错误码",
      "label": "API 错误码"
    }
  },
  "emqx_dashboard_monitor_api": {
    "current_stats": {
      "desc": "当前监控（统计）数据，例如整个集群中的连接数和连接速率。",
      "label": "集群运行统计"
    },
    "current_stats_node": {
      "desc": "节点监控（统计）数据，例如指定节点上的连接数和连接速率。",
      "label": "节点运行统计"
    },
    "current_status": {
      "desc": "包括实时的消息流入/流出速度、连接数/在线连接数、主题数/订阅数指标。",
      "label": "列出集群实时运行指标"
    },
    "current_status_node": {
      "desc": "包括实时的消息流入/流出速度、连接数/在线连接数、主题数/订阅数指标。",
      "label": "列出集群实时运行指标"
    },
    "list_monitor": {
      "desc": "包括历史的连接数/在线连接数、主题数/订阅数、消息流入数、流出数、丢弃数指标。",
      "label": "列出集群历史指标监控数据"
    },
    "list_monitor_node": {
      "desc": "包括连接数/在线连接数、主题数/订阅数、消息流入数、流出数、丢弃数等指标。",
      "label": "列出指定节点的历史指标监控数据"
    }
  },
  "emqx_dashboard_schema": {
    "backlog": {
      "desc": "排队等待连接的队列的最大长度。",
      "label": "排队长度"
    },
    "bind": {
      "desc": "监听地址和端口，热更新此配置时，会重启 Dashboard 服务。",
      "label": "监听地址与端口"
    },
    "bootstrap_users_file": {
      "desc": "已废弃，请使用 api_key.bootstrap_file。",
      "label": "初始化用户列表（已废弃）"
    },
    "cors": {
      "desc": "CORS（Cross-Origin Resource Sharing，跨域资源共享）允许服务器响应来自任何来源（域名、协议或端口）的请求，启用后允许另一个域名下的服务直接通过 JavaScript 调用 EMQX REST API。",
      "label": "CORS"
    },
    "default_password": {
      "desc": "Dashboard 的默认密码，仅在首次启动 EMQX 之前配置有效。为了安全，应该尽快修改密码。",
      "label": "默认密码"
    },
    "default_username": {
      "desc": "Dashboard 的默认用户名，仅在首次启动 EMQX 之前配置有效。",
      "label": "默认用户名"
    },
    "desc_dashboard": {
      "desc": "EMQX Dashboard 配置。",
      "label": "Dashboard"
    },
    "desc_http": {
      "desc": "Dashboard 监听器(HTTP)配置。",
      "label": "HTTP 配置"
    },
    "desc_https": {
      "desc": "Dashboard 监听器(HTTPS)配置。",
      "label": "HTTPS 配置"
    },
    "desc_listeners": {
      "desc": "Dashboard 监听器配置。",
      "label": "监听器"
    },
    "i18n_lang": {
      "desc": "设置 Swagger 多语言的版本，可为 en 或 zh，默认为 en。",
      "label": "Swagger API 默认语言"
    },
    "inet6": {
      "desc": "启用 IPv6， 如果机器不支持 IPv6，请关闭此选项，否则会导致 Dashboard 无法使用。",
      "label": "IPv6"
    },
    "ipv6_v6only": {
      "desc": "当开启 inet6 功能的同时禁用 IPv4-to-IPv6 映射。该配置仅在 inet6 功能开启时有效。",
      "label": "IPv6 only"
    },
    "listener_enable": {
      "desc": "忽略或启用该监听器。",
      "label": "启用监听器"
    },
    "listeners": {
      "desc": "Dashboard 监听器设置。监听器必须有唯一的端口号和 IP 地址的组合。\n例如，可以通过指定 IP 地址 0.0.0.0 来监听机器上给定端口上的所有配置的 IP 地址。\n或者，可以为每个监听器指定唯一的 IP 地址，但使用相同的端口。",
      "label": "监听器"
    },
    "max_connections": {
      "desc": "同时处理的最大连接数。",
      "label": "最大连接数"
    },
    "num_acceptors": {
      "desc": "TCP 协议的 Socket acceptor 池大小, 通常配置为 CPU 核数",
      "label": "Acceptor 数量"
    },
    "proxy_header": {
      "desc": "启用 Proxy Protocol 以提取客户端连接的原始信息，要求使用了代理服务器并且代理服务器也启用 Proxy Protocol。注意：一旦开启了这个功能，就无法再处理普通的 HTTP 请求。",
      "label": "启用 Proxy Protocol"
    },
    "sample_interval": {
      "desc": "Dashboard 中图表指标的时间间隔。必须小于 60，且被 60 的整除，默认为 10s。"
    },
    "send_timeout": {
      "desc": "发送响应内容的超时时间。",
      "label": "发送超时时间"
    },
    "ssl_options": {
      "desc": "Dashboard 监听器的 SSL/TLS 选项。",
      "label": "SSL 选项"
    },
    "token_expired_time": {
      "desc": "登录成功返回的 JWT token 过期时间，默认为 60 分钟。",
      "label": "登录过期时间"
    }
  },
  "emqx_dashboard_sso_ldap": {
    "filter": {
      "desc": "LDAP 中匹配用户的过滤器默认为 `(&(objectClass=person)(uid=${username}))`。 对于 Active Directory，默认过滤器是 `(&(objectClass=user)(sAMAccountName=${username}))`。更多详细内容，请参考 [LDAP Filters](https://ldap.com/ldap-filters/)。",
      "label": "过滤器"
    },
    "ldap_bind": {
      "desc": "使用 LDAP 绑定操作作为认证方式的认证器配置。"
    },
    "query_timeout": {
      "desc": "LDAP 查询超时。",
      "label": "查询超时"
    }
  },
  "emqx_dashboard_sso_saml": {
    "dashboard_addr": {
      "desc": "EMQX Dashboard 的地址。",
      "label": "Dashboard 地址"
    },
    "idp_metadata_url": {
      "desc": "身份提供商的元数据地址。",
      "label": "IdP 元数据 URL"
    },
    "sign_request": {
      "desc": "是否签署 SAML 请求。",
      "label": "签署 SAML 请求"
    },
    "sp_private_key": {
      "desc": "----",
      "label": "SP 私钥"
    },
    "sp_public_key": {
      "desc": "----",
      "label": "SP 公钥"
    }
  },
  "emqx_dashboard_sso_schema": {
    "backend": {
      "desc": "----",
      "label": "后端类型"
    },
    "backend_enable": {
      "desc": "是否启用该后端"
    }
  },
  "emqx_delayed_api": {
    "bad_msgid_format": {
      "desc": "消息 ID 格式错误",
      "label": "消息 ID 格式错误"
    },
    "count": {
      "desc": "延迟消息总数",
      "label": "延迟消息总数"
    },
    "delayed_interval": {
      "desc": "延迟时间(秒)",
      "label": "延迟时间(秒)"
    },
    "delayed_remaining": {
      "desc": "剩余时间(秒)",
      "label": "剩余时间(秒)"
    },
    "delete_api": {
      "desc": "删除延迟消息",
      "label": "删除延迟消息"
    },
    "expected_at": {
      "desc": "期望的发送时间, RFC 3339 格式",
      "label": "期望的发送时间"
    },
    "from_clientid": {
      "desc": "消息的 ClientID",
      "label": "消息的 ClientID"
    },
    "from_username": {
      "desc": "消息的 Username",
      "label": "消息的 Username"
    },
    "get_message_api": {
      "desc": "查看延迟消息",
      "label": "查看延迟消息"
    },
    "illegality_limit": {
      "desc": "数量上限不合法",
      "label": "数量上限不合法"
    },
    "list_api": {
      "desc": "查看延迟消息列表",
      "label": "查看延迟消息列表"
    },
    "msgid": {
      "desc": "延迟消息 ID",
      "label": "延迟消息 ID"
    },
    "msgid_not_found": {
      "desc": "未找到对应消息",
      "label": "未找到对应消息"
    },
    "node": {
      "desc": "消息来源节点",
      "label": "消息来源节点"
    },
    "payload": {
      "desc": "消息内容, base64 格式。如果消息的大小超过 2048 字节，则消息原始内容不予返回，请求将返回 'PAYLOAD_TO_LARGE'",
      "label": "消息内容"
    },
    "publish_at": {
      "desc": "消息发布时间，即延迟消息的创建时间, RFC 3339 格式",
      "label": "消息发布时间"
    },
    "qos": {
      "desc": "QoS",
      "label": "QoS"
    },
    "topic": {
      "desc": "主题",
      "label": "主题"
    },
    "update_api": {
      "desc": "开启或者关闭功能，或者设置延迟消息数量上限",
      "label": "更新配置"
    },
    "update_success": {
      "desc": "配置更新成功",
      "label": "配置更新成功"
    },
    "view_limit": {
      "desc": "每页返回数据条目",
      "label": "分页大小"
    },
    "view_page": {
      "desc": "特定页的页码",
      "label": "分页页码"
    },
    "view_status_api": {
      "desc": "查看慢订阅状态",
      "label": "查看慢订阅状态"
    }
  },
  "emqx_ee_bridge_hstreamdb": {
    "config_direction": {
      "desc": "桥接的方向， 必须是 egress",
      "label": "桥接方向"
    },
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "HStreamDB 桥接配置",
      "label": "HStreamDB 桥接配置"
    },
    "desc_connector": {
      "desc": "连接器的通用配置。",
      "label": "连接器通用配置。"
    },
    "desc_name": {
      "desc": "桥接名字，可读描述",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 HStreamDB。 <br/>\n注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发到 HStreamDB。",
      "label": "本地 Topic"
    },
    "payload": {
      "desc": "要转发到 HStreamDB 的数据内容，支持占位符",
      "label": "消息内容"
    }
  },
  "emqx_ee_bridge_mongodb": {
    "collection": {
      "desc": "数据将被存储到的集合",
      "label": "将要使用的集合（Collection）"
    },
    "desc_config": {
      "desc": "为 MongoDB 桥配置",
      "label": "MongoDB 桥配置"
    },
    "desc_name": {
      "desc": "桥接名称。",
      "label": "桥接名称"
    },
    "desc_type": {
      "desc": "桥接类型。",
      "label": "桥接类型"
    },
    "enable": {
      "desc": "启用或停用该 MongoDB 桥",
      "label": "启用或禁用"
    },
    "mongodb_rs_conf": {
      "desc": "MongoDB（Replica Set）配置",
      "label": "MongoDB（Replica Set）配置"
    },
    "mongodb_sharded_conf": {
      "desc": "MongoDB (Sharded)配置",
      "label": "MongoDB (Sharded)配置"
    },
    "mongodb_single_conf": {
      "desc": "MongoDB（独立）配置",
      "label": "MongoDB（独立）配置"
    },
    "payload_template": {
      "desc": "用于格式化写入 MongoDB 的消息模板。 如果未定义，规则引擎会使用 JSON 格式序列化所有的可见输入，例如 clientid, topic, payload 等。",
      "label": "有效载荷模板"
    }
  },
  "emqx_ee_bridge_mysql": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "HStreamDB 桥接配置",
      "label": "HStreamDB 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字，可读描述",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 MySQL。 <br/>\n注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "sql_template": {
      "desc": "SQL 模板",
      "label": "SQL 模板"
    }
  },
  "emqx_ee_bridge_redis": {
    "command_template": {
      "desc": "用于推送数据的 Redis 命令模板。 每个列表元素代表一个命令名称或其参数。\n例如，要通过键值 `msgs` 将消息体推送到 Redis 列表中，数组元素应该是： `rpush`, `msgs`, `${payload}`。",
      "label": "Redis Command  模板"
    },
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "Resis 桥接配置",
      "label": "Redis 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字，可读描述",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 Redis。 <br/>\n注意：如果这个数据桥接被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发到 Redis。",
      "label": "本地 Topic"
    }
  },
  "emqx_ee_connector_hstreamdb": {
    "config": {
      "desc": "HStreamDB 连接配置。",
      "label": "连接配置"
    },
    "name": {
      "desc": "连接器名称，人类可读的连接器描述。",
      "label": "连接器名称"
    },
    "ordering_key": {
      "desc": "HStreamDB 分区键",
      "label": "HStreamDB 分区键"
    },
    "pool_size": {
      "desc": "HStreamDB 连接池大小",
      "label": "HStreamDB 连接池大小"
    },
    "stream_name": {
      "desc": "HStreamDB 流名称",
      "label": "HStreamDB 流名称"
    },
    "type": {
      "desc": "连接器类型。",
      "label": "连接器类型"
    },
    "url": {
      "desc": "HStreamDB 服务器 URL",
      "label": "HStreamDB 服务器 URL"
    }
  },
  "emqx_ee_schema_registry_http_api": {
    "desc_param_path_schema_name": {
      "desc": "模式名称",
      "label": "模式名称"
    },
    "desc_schema_registry_api_delete": {
      "desc": "删除一个模式",
      "label": "删除模式"
    },
    "desc_schema_registry_api_get": {
      "desc": "通过名称获取模式",
      "label": "获取模式"
    },
    "desc_schema_registry_api_list": {
      "desc": "列出所有注册的模式",
      "label": "列表模式"
    },
    "desc_schema_registry_api_post": {
      "desc": "注册一个新的模式",
      "label": "注册模式"
    },
    "desc_schema_registry_api_put": {
      "desc": "更新一个现有的模式",
      "label": "更新模式"
    }
  },
  "emqx_ee_schema_registry_schema": {
    "avro_type": {
      "desc": "[阿帕奇-阿夫罗](https://avro.apache.org/) 序列化格式。",
      "label": "阿帕奇-阿夫罗"
    },
    "protobuf_type": {
      "desc": "[协议缓冲器](https://protobuf.dev/) 序列化格式。",
      "label": "协议缓冲器"
    },
    "schema_description": {
      "desc": "对该模式的描述。",
      "label": "模式描述"
    },
    "schema_name": {
      "desc": "模式的一个名称，将作为其标识符。",
      "label": "模式名称"
    },
    "schema_registry_root": {
      "desc": "模式注册表的配置。",
      "label": "模式注册表"
    },
    "schema_registry_schemas": {
      "desc": "注册的模式。",
      "label": "注册的模式"
    },
    "schema_source": {
      "desc": "模式的源文本。",
      "label": "模式来源"
    },
    "schema_type": {
      "desc": "模式类型。",
      "label": "模式类型"
    }
  },
  "emqx_eviction_agent_api": {
    "node_eviction_status_get": {
      "desc": "获取节点驱逐状态",
      "label": "节点驱逐状态"
    }
  },
  "emqx_exhook_api": {
    "add_server": {
      "desc": "添加 ExHook 服务器",
      "label": "添加 ExHook 服务器"
    },
    "delete_server": {
      "desc": "删除 Exhook 服务器",
      "label": "删除 Exhook 服务器"
    },
    "get_detail": {
      "desc": "查看 Exhook 服务器详细信息",
      "label": "查看 Exhook 服务器详细信息"
    },
    "get_hooks": {
      "desc": "获取 Exhook 服务器的钩子信息",
      "label": "获取 Exhook 服务器的钩子信息"
    },
    "hook_metrics": {
      "desc": "当前节点中该钩子的指标信息",
      "label": "钩子的指标信息"
    },
    "hook_name": {
      "desc": "钩子的名称",
      "label": "钩子的名称"
    },
    "hook_params": {
      "desc": "钩子注册时使用的参数",
      "label": "钩子参数"
    },
    "list_all_servers": {
      "desc": "查看 ExHook 服务器列表",
      "label": "查看 ExHook 服务器列表"
    },
    "metric_failed": {
      "desc": "钩子执行失败的次数",
      "label": "钩子执行失败的次数"
    },
    "metric_max_rate": {
      "desc": "钩子的最大调用速率",
      "label": "钩子的最大调用速率"
    },
    "metric_rate": {
      "desc": "钩子的调用速率",
      "label": "钩子的调用速率"
    },
    "metric_succeed": {
      "desc": "钩子执行成功的次数",
      "label": "钩子执行成功的次数"
    },
    "metrics": {
      "desc": "指标信息",
      "label": "指标信息"
    },
    "move_api": {
      "desc": "移动 Exhook 服务器顺序。\n注意: 移动的参数只能是：front | rear | before:{name} | after:{name}",
      "label": "改变已注册的 Exhook 服务器的执行顺序"
    },
    "move_position": {
      "desc": "移动的方向",
      "label": "移动的方向"
    },
    "node": {
      "desc": "节点名称",
      "label": "节点名称"
    },
    "node_hook_metrics": {
      "desc": "所有节点中该钩子的指标信息",
      "label": "所有节点中该钩子的指标信息"
    },
    "node_metrics": {
      "desc": "所有节点中该服务器的指标信息",
      "label": "所有节点中该服务器的指标信息"
    },
    "node_status": {
      "desc": "所有节点中该服务器的状态信息",
      "label": "所有节点中该服务器的状态信息"
    },
    "server_metrics": {
      "desc": "当前节点中该服务器的指标信息",
      "label": "当前节点中该服务器的指标信息"
    },
    "server_name": {
      "desc": "Exhook 服务器的名称",
      "label": "Exhook 服务器的名称"
    },
    "status": {
      "desc": "Exhook 服务器的状态。<br/>\nconnected: 连接成功<br/>\nconnecting: 连接失败，重连中<br/>\ndisconnected: 连接失败，且未设置自动重连<br/>\ndisabled: 该服务器未开启<br/>\nerror: 查看该服务器状态时发生错误",
      "label": "Exhook 服务器的状态"
    },
    "update_server": {
      "desc": "更新 Exhook 服务器",
      "label": "更新 Exhook 服务器"
    }
  },
  "emqx_exhook_schema": {
    "auto_reconnect": {
      "desc": "自动重连到 gRPC 服务器的设置。\n当 gRPC 服务器不可用时，Exhook 将会按照这里设置的间隔时间进行重连，并重新初始化注册的钩子"
    },
    "enable": {
      "desc": "开启这个 Exhook 服务器"
    },
    "failed_action": {
      "desc": "当 gRPC 请求失败后的操作"
    },
    "keepalive": {
      "desc": "当没有其他数据交换时，是否向连接的对端套接字定期的发送探测包。如果另一端没有响应，则认为连接断开，并向控制进程发送错误消息。"
    },
    "name": {
      "desc": "ExHook 服务器名称"
    },
    "nodelay": {
      "desc": "如果为 true，则为套接字设置 TCP_NODELAY 选项，这意味着会立即发送数据包"
    },
    "pool_size": {
      "desc": "gRPC 客户端进程池大小"
    },
    "recbuf": {
      "desc": "套接字的最小接收缓冲区大小"
    },
    "request_timeout": {
      "desc": "gRPC 服务器请求超时"
    },
    "servers": {
      "desc": "ExHook 服务器列表"
    },
    "sndbuf": {
      "desc": "套接字的最小发送缓冲区大小"
    },
    "socket_options": {
      "desc": "连接套接字设置"
    },
    "url": {
      "desc": "gRPC 服务器地址"
    }
  },
  "emqx_exproto_schema": {
    "exproto": {
      "desc": "ExProto 网关"
    },
    "exproto_grpc_handler_address": {
      "desc": "对端 gRPC 服务器地址。"
    },
    "exproto_grpc_handler_service_name": {
      "desc": "用于处理连接事件的服务名称\n在初始版本中，我们期望使用流来提高 ConnectionHandler 中请求的效率。\n但不幸的是，不同流之间的事件顺序混乱。\n这导致 OnSocketCreated 事件可能会\n在 OnReceivedBytes 之后到达。\n因此，自 v5.0.25 起，我们添加了 `ConnectionUnaryHandler` 服务，并强制在其中使用了 Unary，以避免顺序问题。"
    },
    "exproto_grpc_handler_ssl": {
      "desc": "gRPC 客户端的 SSL 配置。"
    },
    "exproto_grpc_server_bind": {
      "desc": "服务监听地址和端口。"
    },
    "exproto_grpc_server_ssl": {
      "desc": "服务 SSL 配置。"
    },
    "exproto_handler": {
      "desc": "配置 ExProto 网关需要请求的 <code>ConnectionHandler</code> 服务地址。\n该服务用于给 ExProto 提供客户端的 Socket 事件处理、字节解码、订阅消息接收等功能。"
    },
    "exproto_server": {
      "desc": "配置 ExProto 网关需要启动的 <code>ConnectionAdapter</code> 服务。\n该服务用于提供客户端的认证、发布、订阅和数据下行等功能。"
    }
  },
  "emqx_ft_api": {
    "file_list": {
      "desc": "列出已上传的所有文件"
    },
    "file_list_transfer": {
      "desc": "根据客户端 ID 或者文件 ID 列出所有已上传的文件"
    },
    "file_transfer_get_config": {
      "desc": "显示当前文件传输配置。"
    },
    "file_transfer_update_config": {
      "desc": "替换文件传输配置。"
    }
  },
  "emqx_ft_schema": {
    "assemble_timeout": {
      "desc": "文件拼接超时。<br/>\n在收到 'fin' 消息后 EMQX 会对文件进行拼接，如果发生超时（例如系统过载），则会给 'fin' 的 PUBACK 中包含一个错误码（0x80）。"
    },
    "backend_enable": {
      "desc": "是否启用该后端"
    },
    "enable": {
      "desc": "启用文件传输（File Transfer）服务。<br/>\n文件传输服务允许客户端使用 `$file` 主题将分片上传到 EMQX。\n启用文件传输服务表示 `$file` 主题前缀已被预留，用于提供文件传输服务。<br/>\n这个开关也会影响文件传输 REST API 的可用性，以及依赖存储的后台任务（例如垃圾回收）。"
    },
    "init_timeout": {
      "desc": "指定文件传输初始化的时间限制。在<br/>\nEMQX 服务器过载时可能发生初始化超时。超时后给 `init` 的 PUBACK 中包含一个错误码 （0x80）。"
    },
    "local_storage": {
      "desc": "EMQX 节点本地用文件系统于存储文件分片的相关配置。"
    },
    "local_storage_exporter": {
      "desc": "将文件导出到本地存储。"
    },
    "local_storage_exporter_backend": {
      "desc": "将文件导出到本地存储<br/>\n该配置项指定所有分片都传输完成了的文件进行导出到本地存储的相关行为。"
    },
    "local_storage_exporter_root": {
      "desc": "导出到本地文件时使用的根目录。"
    },
    "local_storage_segments": {
      "desc": "本地文件系统存储配置，包括已上传的文件分片和临时数据。"
    },
    "local_storage_segments_gc": {
      "desc": "文件系统中临时文件的垃圾回收配置。"
    },
    "local_storage_segments_root": {
      "desc": "文件分片存储的根目录。"
    },
    "s3_exporter": {
      "desc": "将文件导出到 AWS s3 API 兼容的对象存储服务。"
    },
    "storage_backend": {
      "desc": "文件后端存储配置"
    },
    "storage_gc_interval": {
      "desc": "运行垃圾回收的时间间隔。"
    },
    "storage_gc_max_segments_ttl": {
      "desc": "分片的临时存储的最大 TTL。<br/>\n该配置为系统全局上限，所有的分片都不会超过这个 TTL，即使某些文件传输指定了一个更大的 TTL。"
    },
    "storage_gc_min_segments_ttl": {
      "desc": "分片的临时存储的最小 TTL。<br/>\n分片在超过这个 TTL 之前不被垃圾回收。\n该配置为系统全局下限，所有的分片都不会低于这个 TTL，即使某些文件传输指定了一个更小的 TTL。"
    },
    "store_segment_timeout": {
      "desc": "文件片段保存超时。<br/>\nEMQX 收到文件分片后，会对它进行保存，如果发生超时（例如系统过载），则会给这个发布消息的 PUBACK 中包含一个错误码（0x80）。"
    }
  },
  "emqx_ft_storage_exporter_fs_api": {
    "file_get": {
      "desc": "根据文件 ID 下载指定文件"
    }
  },
  "emqx_gateway_api": {
    "delete_gateway": {
      "desc": "停用指定网关"
    },
    "enable_gateway": {
      "desc": "使用配置启动某一网关。"
    },
    "gateway_created_at": {
      "desc": "网关创建时间"
    },
    "gateway_current_connections": {
      "desc": "当前连接数"
    },
    "gateway_enable_in_path": {
      "desc": "是否开启此网关"
    },
    "gateway_listener_id": {
      "desc": "监听器 ID"
    },
    "gateway_listener_name": {
      "desc": "监听器名称"
    },
    "gateway_listener_running": {
      "desc": "监听器运行状态"
    },
    "gateway_listener_type": {
      "desc": "监听器类型"
    },
    "gateway_listeners": {
      "desc": "网关监听器列表"
    },
    "gateway_max_connections": {
      "desc": "最大连接数"
    },
    "gateway_name": {
      "desc": "网关名称"
    },
    "gateway_name_in_qs": {
      "desc": "网关名称.<br/>\n可取值为 `stomp`、`mqttsn`、`coap`、`lwm2m`、`exproto`"
    },
    "gateway_node_status": {
      "desc": "网关在集群中每个节点上的状态"
    },
    "gateway_started_at": {
      "desc": "网关启用时间"
    },
    "gateway_status": {
      "desc": "网关启用状态"
    },
    "gateway_status_in_qs": {
      "desc": "通过网关状态筛选<br/>\n状态是一个枚举类型，包括 `running`、`stopped`、`unloaded`"
    },
    "gateway_stopped_at": {
      "desc": "网关停用时间"
    },
    "get_gateway": {
      "desc": "获取网关配置详情"
    },
    "list_gateway": {
      "desc": "该接口会返回指定或所有网关的概览状态，\n包括当前状态、连接数、监听器状态等。"
    },
    "node": {
      "desc": "节点名称"
    },
    "update_gateway": {
      "desc": "更新指定网关的基础配置、和启用的状态。<br/>\n注：认证、和监听器的配置更新需参考对应的 API 接口。"
    }
  },
  "emqx_gateway_api_authn": {
    "add_authn": {
      "desc": "为指定网关开启认证器实现客户端认证的功能。<br/>\n当未配置认证器或关闭认证器时，则认为允许所有客户端的连接。<br/>\n注：在网关中仅支持添加一个认证器，而不是像 MQTT 一样允许配置多个认证器构成认证链。"
    },
    "add_user": {
      "desc": "添加用户（仅支持 built_in_database 类型的认证器）"
    },
    "delete_authn": {
      "desc": "删除指定网关的认证器。"
    },
    "delete_user": {
      "desc": "删除用户（仅支持 built_in_database 类型的认证器）"
    },
    "get_authn": {
      "desc": "获取指定网关认证器的配置\n当网关或认证未启用时，返回 404。"
    },
    "get_user": {
      "desc": "获取用户信息（仅支持 built_in_database 类型的认证器）"
    },
    "import_users": {
      "desc": "导入用户（仅支持 built_in_database 类型的认证器）"
    },
    "is_superuser": {
      "desc": "是否是超级用户"
    },
    "like_user_id": {
      "desc": "使用用户 ID （username 或 clientid）模糊搜索，仅支持按子串的方式进行搜索。"
    },
    "list_users": {
      "desc": "获取用户列表（仅支持 built_in_database 类型的认证器）"
    },
    "update_authn": {
      "desc": "更新指定网关认证器的配置，或停用认证器。"
    },
    "update_user": {
      "desc": "更新用户信息（仅支持 built_in_database 类型的认证器）"
    },
    "user_id": {
      "desc": "用户 ID"
    }
  },
  "emqx_gateway_api_clients": {
    "add_subscription": {
      "desc": "为某客户端新增订阅关系"
    },
    "awaiting_rel_cnt": {
      "desc": "客户端当前等待 PUBREL 确认的 PUBREC 消息的条数"
    },
    "awaiting_rel_max": {
      "desc": "客户端允许的最大 PUBREC 等待队列长度"
    },
    "clean_start": {
      "desc": "标识客户端是否以 clean_start 的标志连接到网关"
    },
    "clientid": {
      "desc": "客户端 ID"
    },
    "connected": {
      "desc": "标识客户端是否已连接到网关"
    },
    "connected_at": {
      "desc": "客户端连接时间"
    },
    "created_at": {
      "desc": "会话创建时间"
    },
    "delete_subscription": {
      "desc": "为某客户端删除某订阅关系"
    },
    "disconnected_at": {
      "desc": "客户端连接断开时间"
    },
    "endpoint_name": {
      "desc": "LwM2M 客户端 Endpoint Name"
    },
    "expiry_interval": {
      "desc": "会话超期时间，单位：秒"
    },
    "get_client": {
      "desc": "获取客户端信息"
    },
    "heap_size": {
      "desc": "进程堆内存大小，单位：字节"
    },
    "inflight_cnt": {
      "desc": "客户端当前飞行窗口大小"
    },
    "inflight_max": {
      "desc": "客户端允许的飞行窗口最大值"
    },
    "ip_address": {
      "desc": "客户端 IP 地址"
    },
    "is_bridge": {
      "desc": "标识客户端是否通过 is_bridge 标志连接"
    },
    "keepalive": {
      "desc": "Keepalive 时间，单位：秒"
    },
    "kick_client": {
      "desc": "踢出指定客户端"
    },
    "lifetime": {
      "desc": "LwM2M 客户端心跳周期"
    },
    "list_clients": {
      "desc": "获取指定网关的客户端列表"
    },
    "list_subscriptions": {
      "desc": "获取某客户端的主题订阅列表"
    },
    "mailbox_len": {
      "desc": "进程邮箱大小"
    },
    "mountpoint": {
      "desc": "主题固定前缀"
    },
    "mqueue_dropped": {
      "desc": "由于消息队列过程，客户端消息队列丢弃消息条数"
    },
    "mqueue_len": {
      "desc": "客户端当前消息队列长度"
    },
    "mqueue_max": {
      "desc": "客户端允许的最大消息队列长度"
    },
    "nl": {
      "desc": "No Local 选项，枚举：0，1"
    },
    "node": {
      "desc": "客户端连接到的节点名称"
    },
    "param_clean_start": {
      "desc": "匹配客户端 `clean_start` 标记"
    },
    "param_clientid": {
      "desc": "匹配客户端 ID"
    },
    "param_conn_state": {
      "desc": "匹配客户端连接状态"
    },
    "param_endpoint_name": {
      "desc": "匹配 LwM2M 客户端 Endpoint Name"
    },
    "param_gte_connected_at": {
      "desc": "匹配连接创建时间大于等于指定值的客户端"
    },
    "param_gte_created_at": {
      "desc": "匹配会话创建时间大于等于指定值的客户端"
    },
    "param_gte_lifetime": {
      "desc": "匹配心跳时间大于等于指定值的 LwM2M 客户端"
    },
    "param_ip_address": {
      "desc": "匹配客户端 IP 地址"
    },
    "param_like_clientid": {
      "desc": "子串匹配客户端 ID"
    },
    "param_like_endpoint_name": {
      "desc": "子串匹配 LwM2M 客户端 Endpoint Name"
    },
    "param_like_username": {
      "desc": "子串匹配 客户端 Username"
    },
    "param_lte_connected_at": {
      "desc": "匹配连接创建时间小于等于指定值的客户端"
    },
    "param_lte_created_at": {
      "desc": "匹配会话创建时间小于等于指定值的客户端"
    },
    "param_lte_lifetime": {
      "desc": "匹配心跳时间小于等于指定值的 LwM2M 客户端"
    },
    "param_node": {
      "desc": "匹配客户端的节点名称"
    },
    "param_proto_ver": {
      "desc": "匹配客户端协议版本"
    },
    "param_username": {
      "desc": "匹配客户端 Username"
    },
    "port": {
      "desc": "客户端端口"
    },
    "proto_name": {
      "desc": "客户端使用的协议名称"
    },
    "proto_ver": {
      "desc": "客户端使用的协议版本"
    },
    "qos": {
      "desc": "QoS 等级，枚举：0，1，2"
    },
    "rap": {
      "desc": "Retain as Published 选项，枚举：0，1"
    },
    "recv_cnt": {
      "desc": "已接收 Socket 报文次数"
    },
    "recv_msg": {
      "desc": "已接收上行的消息条数"
    },
    "recv_oct": {
      "desc": "已接收的字节数"
    },
    "recv_pkt": {
      "desc": "已接收应用层协议控制报文数"
    },
    "reductions": {
      "desc": "进程已消耗 Reduction 数"
    },
    "rh": {
      "desc": "Retain Handling 选项，枚举：0，1，2"
    },
    "send_cnt": {
      "desc": "已发送 Socket 报文次数"
    },
    "send_msg": {
      "desc": "已发送下行消息数条数"
    },
    "send_oct": {
      "desc": "已发送字节数"
    },
    "send_pkt": {
      "desc": "已发送应用层协议控制报文数"
    },
    "sub_props": {
      "desc": "订阅属性"
    },
    "subid": {
      "desc": "订阅 ID，仅用于 Stomp 网关。用于创建订阅关系时指定订阅 ID。取值范围 1-65535。"
    },
    "subscriptions_cnt": {
      "desc": "客户端已订阅主题数"
    },
    "subscriptions_max": {
      "desc": "客户端允许订阅的最大主题数"
    },
    "topic": {
      "desc": "主题过滤器或主题名称"
    },
    "username": {
      "desc": "客户端连接的用户名"
    }
  },
  "emqx_gateway_api_listeners": {
    "add_listener": {
      "desc": "为指定网关添加监听器。<br/>\n注：对于某网关不支持的监听器类型，该接口会返回 `400: BAD_REQUEST`。"
    },
    "add_listener_authn": {
      "desc": "为指定监听器开启认证器以实现客户端认证的能力。<br/>\n当某一监听器开启认证后，所有连接到该监听器的客户端会使用该认证器进行认证。"
    },
    "add_user": {
      "desc": "添加用户（仅支持 built_in_database 类型的认证器）"
    },
    "current_connections": {
      "desc": "当前连接数"
    },
    "delete_listener": {
      "desc": "删除指定监听器。被删除的监听器下所有已连接的客户端都会离线。"
    },
    "delete_listener_authn": {
      "desc": "移除指定监听器的认证器。"
    },
    "delete_user": {
      "desc": "删除用户（仅支持 built_in_database 类型的认证器）"
    },
    "get_listener": {
      "desc": "获取指定网关监听器的配置。"
    },
    "get_listener_authn": {
      "desc": "获取监听器的认证器配置。"
    },
    "get_user": {
      "desc": "获取用户信息（仅支持 built_in_database 类型的认证器）"
    },
    "import_users": {
      "desc": "导入用户（仅支持 built_in_database 类型的认证器）"
    },
    "list_listeners": {
      "desc": "获取网关监听器列表。该接口会返回监听器所有的配置（包括该监听器上的认证器），同时也会返回该监听器在集群中运行的状态。"
    },
    "list_users": {
      "desc": "获取用户列表（仅支持 built_in_database 类型的认证器）"
    },
    "listener_id": {
      "desc": "监听器 ID"
    },
    "listener_node_status": {
      "desc": "监听器在集群中每个节点上的状态"
    },
    "listener_status": {
      "desc": "监听器状态"
    },
    "node": {
      "desc": "节点名称"
    },
    "update_listener": {
      "desc": "更新某网关监听器的配置。被更新的监听器会执行重启，所有已连接到该监听器上的客户端都会被断开。"
    },
    "update_listener_authn": {
      "desc": "更新指定监听器的认证器配置，或停用/启用该认证器。"
    },
    "update_user": {
      "desc": "更新用户信息（仅支持 built_in_database 类型的认证器）"
    }
  },
  "emqx_gateway_schema": {
    "dtls_listener_acceptors": {
      "desc": "Acceptor 进程池大小。"
    },
    "dtls_listener_dtls_opts": {
      "desc": "DTLS Socket 配置"
    },
    "gateway_common_authentication": {
      "desc": "网关的认证器配置，对该网关下所以的监听器生效。如果每个监听器需要配置不同的认证器，需要配置监听器下的 <code>authentication</code> 字段"
    },
    "gateway_common_clientinfo_override": {
      "desc": "ClientInfo 重写。"
    },
    "gateway_common_clientinfo_override_clientid": {
      "desc": "clientid 重写模板"
    },
    "gateway_common_clientinfo_override_password": {
      "desc": "password 重写模板"
    },
    "gateway_common_clientinfo_override_username": {
      "desc": "username 重写模板"
    },
    "gateway_common_enable": {
      "desc": "是否启用该网关"
    },
    "gateway_common_enable_stats": {
      "desc": "是否开启客户端统计"
    },
    "gateway_common_idle_timeout": {
      "desc": "客户端连接过程的空闲时间。该配置用于：\n  1. 一个新创建的客户端进程如果在该时间间隔内没有收到任何客户端请求，将被直接关闭。\n  2. 一个正在运行的客户进程如果在这段时间后没有收到任何客户请求，将进入休眠状态以节省资源。"
    },
    "gateway_common_listener_access_rules": {
      "desc": "配置监听器的访问控制规则。\n见：https://github.com/emqtt/esockd#allowdeny"
    },
    "gateway_common_listener_bind": {
      "desc": "监听器绑定的 IP 地址或端口。"
    },
    "gateway_common_listener_enable": {
      "desc": "是否启用该监听器。"
    },
    "gateway_common_listener_enable_authn": {
      "desc": "配置 <code>true</code> （默认值）启用客户端进行身份认证。\n配置 <code>false</code> 时，将不对客户端做任何认证。"
    },
    "gateway_common_listener_max_conn_rate": {
      "desc": "监听器支持的最大连接速率。"
    },
    "gateway_common_listener_max_connections": {
      "desc": "监听器支持的最大连接数。"
    },
    "gateway_mountpoint": {
      "desc": "发布或订阅时，在所有主题前增加前缀字符串。\n当消息投递给订阅者时，前缀字符串将从主题名称中删除。挂载点是用户可以用来实现不同监听器之间的消息路由隔离的一种方式。\n例如，如果客户端 A 在 `listeners.tcp.\\<name>.mountpoint` 设置为 `some_tenant` 的情况下订阅 `t`，\n则客户端实际上订阅了 `some_tenant/t` 主题。\n类似地，如果另一个客户端 B（连接到与客户端 A 相同的侦听器）向主题 `t` 发送消息，\n则该消息被路由到所有订阅了 `some_tenant/t` 的客户端，因此客户端 A 将收到该消息，带有 主题名称`t`。 设置为 `\"\"` 以禁用该功能。\n挂载点字符串中可用的变量：<br/>\n   - <code>${clientid}</code>：clientid<br/>\n   - <code>${username}</code>：用户名"
    },
    "listener_name_to_settings_map": {
      "desc": "从监听器名称到配置参数的映射。"
    },
    "ssl_listener_options": {
      "desc": "SSL Socket 配置。"
    },
    "tcp_listener_acceptors": {
      "desc": "Acceptor 进程池大小。"
    },
    "tcp_listener_proxy_protocol": {
      "desc": "是否开启 Proxy Protocol V1/2。当 EMQX 集群部署在 HAProxy 或 Nginx 后需要获取客户端真实 IP 时常用到该选项。参考：https://www.haproxy.com/blog/haproxy/proxy-protocol/"
    },
    "tcp_listener_proxy_protocol_timeout": {
      "desc": "接收 Proxy Protocol 报文头的超时时间。如果在超时内没有收到 Proxy Protocol 包，EMQX 将关闭 TCP 连接。"
    },
    "tcp_listener_tcp_opts": {
      "desc": "TCP Socket 配置。"
    },
    "tcp_listeners": {
      "desc": "配置 TCP 类型的监听器。"
    },
    "tcp_udp_listeners": {
      "desc": "监听器配置。"
    },
    "udp_listener_active_n": {
      "desc": "为 Socket 指定 {active, N} 选项。\n参见：https://erlang.org/doc/man/inet.html#setopts-2"
    },
    "udp_listener_buffer": {
      "desc": "Socket 在用户空间的缓冲区大小。"
    },
    "udp_listener_recbuf": {
      "desc": "Socket 在内核空间接收缓冲区的大小。"
    },
    "udp_listener_reuseaddr": {
      "desc": "允许重用本地处于 TIME_WAIT 的端口号。"
    },
    "udp_listener_sndbuf": {
      "desc": "Socket 在内核空间发送缓冲区的大小。"
    },
    "udp_listener_udp_opts": {
      "desc": "UDP Socket 配置。"
    },
    "udp_listeners": {
      "desc": "配置 UDP 类型的监听器。"
    }
  },
  "emqx_gcp_device_api": {
    "blocked": {
      "desc": "禁用",
      "label": "设备是否被禁用与 GCP IoT Core 通信"
    },
    "config": {
      "desc": "配置",
      "label": "设备配置"
    },
    "created_at": {
      "desc": "GCP 设备导入时间",
      "label": "创建时间"
    },
    "deviceid": {
      "desc": "设备标识",
      "label": "设备标识"
    },
    "expires_at": {
      "desc": "公钥过期时间",
      "label": "过期时间"
    },
    "gcp_device": {
      "desc": "使用 GCP 设备作为认证数据源的认证器配置。"
    },
    "gcp_device_delete": {
      "desc": "移除一个从 GCP IoT Core 导入的设备",
      "label": "移除 GCP 设备"
    },
    "gcp_device_get": {
      "desc": "获取一个从 GCP IoT Core 导入的设备",
      "label": "获取 GCP 设备"
    },
    "gcp_device_put": {
      "desc": "更新一个从 GCP IoT Core 导入的设备",
      "label": "更新 GCP 设备"
    },
    "gcp_device_response404": {
      "desc": "未找到 GCP 设备"
    },
    "gcp_devices_get": {
      "desc": "列出所有从 GCP IoT Core 导入的设备",
      "label": "列出所有 GCP 设备"
    },
    "gcp_devices_post": {
      "desc": "从 GCP IoT Core 导入认证和配置数据",
      "label": "导入 GCP 设备"
    },
    "imported_counter": {
      "desc": "成功导入的 GCP 设备数量"
    },
    "imported_counter_errors": {
      "desc": "因错误未被导入的 GCP 设备数量"
    },
    "key": {
      "desc": "----",
      "label": "公钥"
    },
    "key_type": {
      "desc": "----",
      "label": "公钥类型"
    },
    "keys": {
      "desc": "与 GCP 设备关联的公钥",
      "label": "公钥"
    },
    "location": {
      "desc": "部署所在区域",
      "label": "区域"
    },
    "project": {
      "desc": "项目标识",
      "label": "项目"
    },
    "registry": {
      "desc": "设备注册标识",
      "label": "注册"
    }
  },
  "emqx_ldap": {
    "base_dn": {
      "desc": "与基本对象条目（或根）相关的名称。\n搜索用户的起点。",
      "label": "Base DN"
    },
    "bind_password": {
      "desc": "绑定密码的模版",
      "label": "绑定的密码"
    },
    "filter": {
      "desc": "定义哪些条件必须被依次满足的过滤器\n用于搜索匹配一条给定的条目.<br>\n筛选器的语法遵循 RFC 4515，并且还支持占位符。",
      "label": "过滤器"
    },
    "request_timeout": {
      "desc": "设置每个单独请求所使用的最大时间（以毫秒为单位）。",
      "label": "请求超时"
    },
    "server": {
      "desc": "要连接的 IPv4 或 IPv6 地址或主机名。<br/>\n主机名条目的格式为：`主机[:端口]`。<br/>\n如果 `[:端口]` 未指定， 将使用 LDAP 默认端口 389。",
      "label": "服务器地址"
    }
  },
  "emqx_license_http_api": {
    "desc_license_info_api": {
      "desc": "获取 License 信息",
      "label": "License 信息"
    },
    "desc_license_key_api": {
      "desc": "更新一个 License 密钥",
      "label": "更新 License"
    },
    "desc_license_setting_api": {
      "desc": "----",
      "label": "更新 license 设置"
    }
  },
  "emqx_license_schema": {
    "connection_high_watermark_field": {
      "desc": "连接数超过该值时，系统会触发 License 连接配额使用告警",
      "label": "连接高水位线"
    },
    "connection_high_watermark_field_deprecated": {
      "desc": "----",
      "label": "已弃用，请使用 /license/setting 代替"
    },
    "connection_low_watermark_field": {
      "desc": "连接数低于此值是，系统会清除连接配额使用告警",
      "label": "连接低水位线"
    },
    "connection_low_watermark_field_deprecated": {
      "desc": "----",
      "label": "已弃用，请使用 /license/setting 代替"
    },
    "key_field": {
      "desc": "申请或购买 License 时获得的密钥字符串",
      "label": "License Key"
    },
    "license_root": {
      "desc": "EMQX 企业版 License 。\nEMQX 自带一个默认的试用 License，允许最多接入 100 个连接，签发时间是 2023 年 1 月 9 日，有效期是 5 年（1825 天）。若需要在生产环境部署，\n请购买 License 或访问 https://www.emqx.com/apply-licenses/emqx 申请。",
      "label": "License"
    }
  },
  "emqx_limiter_schema": {
    "bytes_rate": {
      "desc": "数据发布速率。<br/>\n这用于限制该节点的入站字节速率。\n一旦达到限制，受限制的客户端将减速甚至暂时挂起。<br/>\n字节的单位可以是：KB MB GB。<br/>\n例如：<br/>\n- <code>500KB/s</code>：每秒只发送前500千字节，其他消息被缓冲。<br/>\n- <code>500MB/10s</code>：即使是10秒，也只发送前500兆字节，其他消息被缓冲。",
      "label": "数据发布速率"
    },
    "max_conn_rate": {
      "desc": "最大连接速率。<br/>\n这用于限制该节点的连接速率。\n一旦达到限制，新的连接将被推迟或拒绝。<br/>\n例如：<br/>\n- <code>1000/s</code>：每秒只接受1000个连接<br/>\n- <code>1000/10s</code>：每10秒只接受1000个连接。",
      "label": "最大连接速率"
    },
    "messages_rate": {
      "desc": "消息发布速率。<br/>\n这用于限制该节点的入站消息数量。\n一旦达到限制，受限制的客户端将减速甚至暂时挂起。<br/>\n例如：<br/>\n- <code>500/s</code>：每秒只发送前500条消息，其他消息被缓冲。<br/>\n- <code>500/10s</code>：即使是10秒，也只发送前500条消息，其他消息被缓冲。",
      "label": "消息发布速率"
    }
  },
  "emqx_lwm2m_api": {
    "dataType": {
      "desc": "数据类型"
    },
    "lookup_resource": {
      "desc": "查看指定资源状态"
    },
    "name": {
      "desc": "资源名称"
    },
    "observe_resource": {
      "desc": "Observe/Un-Observe 指定资源"
    },
    "operations": {
      "desc": "资源可用操作列表"
    },
    "path": {
      "desc": "资源路径"
    },
    "read_resource": {
      "desc": "发送读指令到某资源"
    },
    "write_resource": {
      "desc": "发送写指令到某资源"
    }
  },
  "emqx_lwm2m_schema": {
    "lwm2m": {
      "desc": "LwM2M 网关配置。仅支持 v1.0.1 协议。"
    },
    "lwm2m_auto_observe": {
      "desc": "自动 Observe REGISTER 数据包的 Object 列表。"
    },
    "lwm2m_lifetime_max": {
      "desc": "允许 LwM2M 客户端允许设置的心跳最大值。"
    },
    "lwm2m_lifetime_min": {
      "desc": "允许 LwM2M 客户端允许设置的心跳最小值。"
    },
    "lwm2m_qmode_time_window": {
      "desc": "在 QMode 模式下，LwM2M 网关认为网络链接有效的时间窗口的值。\n例如，在收到客户端的更新信息后，在这个时间窗口内的任何信息都会直接发送到 LwM2M 客户端，而超过这个时间窗口的所有信息都会暂时储存在内存中。"
    },
    "lwm2m_translators": {
      "desc": "LwM2M 网关订阅/发布消息的主题映射配置。"
    },
    "lwm2m_translators_command": {
      "desc": "下行命令主题。\n对于每个成功上线的新 LwM2M 客户端，网关会创建一个订阅关系来接收下行消息并将其发送给客户端"
    },
    "lwm2m_translators_notify": {
      "desc": "用于发布来自 LwM2M 客户端的通知事件的主题。\n在成功 Observe 到 LwM2M 客户端的资源后，如果客户端报告任何资源状态的变化，网关将通过该主题发送通知事件"
    },
    "lwm2m_translators_register": {
      "desc": "用于发布来自 LwM2M 客户端的注册事件的主题。"
    },
    "lwm2m_translators_response": {
      "desc": "用于网关发布来自 LwM2M 客户端的确认事件的主题。"
    },
    "lwm2m_translators_update": {
      "desc": "用于发布来自 LwM2M 客户端的更新事件的主题。"
    },
    "lwm2m_update_msg_publish_condition": {
      "desc": "发布 UPDATE 事件消息的策略。<br/>\n  - always: 只要收到 UPDATE 请求，就发送更新事件。<br/>\n  - contains_object_list: 仅当 UPDATE 请求携带 Object 列表时才发送更新事件。"
    },
    "lwm2m_xml_dir": {
      "desc": "LwM2M Resource 定义的 XML 文件目录路径。"
    },
    "translator": {
      "desc": "配置某网关客户端对于发布消息或订阅的主题和 QoS 等级。"
    },
    "translator_qos": {
      "desc": "QoS 等级"
    },
    "translator_topic": {
      "desc": "主题名称"
    }
  },
  "emqx_mgmt_api_alarms": {
    "activate_at": {
      "desc": "告警开始时间，使用 rfc3339 标准时间格式。"
    },
    "deactivate_at": {
      "desc": "告警结束时间，使用 rfc3339 标准时间格式。"
    },
    "delete_alarms_api": {
      "desc": "删除所有历史告警。",
      "label": "删除所有历史告警"
    },
    "delete_alarms_api_response204": {
      "desc": "历史告警已成功清除。"
    },
    "details": {
      "desc": "告警详情，提供了更多的告警信息，主要提供给程序处理。"
    },
    "duration": {
      "desc": "表明告警已经持续了多久，单位：毫秒。"
    },
    "get_alarms_qs_activated": {
      "desc": "用于指定查询的告警类型，\n为 true 时返回当前激活的告警，为 false 时返回历史告警，默认为 false。"
    },
    "list_alarms_api": {
      "desc": "列出当前激活的告警或历史告警，由查询参数决定。",
      "label": "列出告警"
    },
    "message": {
      "desc": "告警消息，以人类可读的方式描述告警内容。"
    },
    "name": {
      "desc": "告警名称，用于区分不同的告警。"
    },
    "node": {
      "desc": "触发此告警的节点名称。"
    }
  },
  "emqx_mgmt_api_api_keys": {
    "api_key_list": {
      "desc": "查看 API 密钥列表",
      "label": "API 密钥列表"
    },
    "create_new_api_key": {
      "desc": "创建一个新的 API 密钥",
      "label": "创建 API 密钥"
    },
    "delete_api_key": {
      "desc": "指定 API 密钥 ID 进行删除",
      "label": "删除指定 API 密钥"
    },
    "format": {
      "desc": "ID 需要唯一并且符合 [a-zA-Z0-9-_] 格式",
      "label": "ID 需要唯一并且符合 [a-zA-Z0-9-_] 格式"
    },
    "get_api_key": {
      "desc": "指定 API 密钥 ID 获取详情",
      "label": "获取 API 密钥详情"
    },
    "update_api_key": {
      "desc": "指定 API 密钥 ID 进行更新",
      "label": "更新指定 API 密钥"
    }
  },
  "emqx_mgmt_api_banned": {
    "as": {
      "desc": "封禁方式，可以通过客户端 ID、用户名或者 IP 地址等方式进行封禁。",
      "label": "封禁方式"
    },
    "at": {
      "desc": "封禁的起始时间，格式为 rfc3339，默认为发起操作的时间。",
      "label": "封禁时间"
    },
    "by": {
      "desc": "封禁的发起者。",
      "label": "封禁发起者"
    },
    "clear_banned_api": {
      "desc": "清除全部黑名单数据。",
      "label": "清除"
    },
    "create_banned_api": {
      "desc": "添加一个客户端 ID、用户名或者 IP 地址到黑名单。",
      "label": "添加一个新的黑名单条目"
    },
    "create_banned_api_response400": {
      "desc": "错误的请求，可能是参数错误或封禁对象已存在等原因。"
    },
    "delete_banned_api": {
      "desc": "将一个客户端 ID、用户名或者 IP 地址从黑名单中删除。",
      "label": "从黑名单中移除"
    },
    "delete_banned_api_response404": {
      "desc": "未在黑名单中找到该封禁对象。"
    },
    "list_banned_api": {
      "desc": "列出目前所有被封禁的客户端 ID、用户名和 IP 地址。",
      "label": "列出目前所有被封禁的客户端"
    },
    "reason": {
      "desc": "封禁原因，记录当前对象被封禁的原因。",
      "label": "封禁原因"
    },
    "until": {
      "desc": "封禁的结束时间，格式为 rfc3339，默认值为发起操作的时间 + 1 年。",
      "label": "封禁结束时间"
    },
    "who": {
      "desc": "封禁对象，具体的客户端 ID、用户名或者 IP 地址。",
      "label": "封禁对象"
    }
  },
  "emqx_mgmt_api_clients": {
    "clean_authz_cache": {
      "desc": "清除指定客户端的授权缓存",
      "label": "清除指定客户端的授权缓存"
    },
    "clients_info_from_id": {
      "desc": "获取指定客户端的详细信息",
      "label": "获取指定客户端信息"
    },
    "get_authz_cache": {
      "desc": "获取指定客户端的授权缓存",
      "label": "获取指定客户端的授权缓存"
    },
    "get_client_subs": {
      "desc": "获取指定客户端的订阅列表",
      "label": "获取客户端订阅"
    },
    "kick_client_id": {
      "desc": "踢出指定客户端",
      "label": "踢出指定客户端"
    },
    "kickout_clients": {
      "desc": "----",
      "label": "根据客户端 ID 批量踢除客户端"
    },
    "list_clients": {
      "desc": "列出客户端",
      "label": "列出客户端"
    },
    "set_keepalive_seconds": {
      "desc": "设置客户端的 MQTT 心跳保活时间",
      "label": "设置客户端的 MQTT 心跳保活时间"
    },
    "subscribe": {
      "desc": "订阅",
      "label": "订阅"
    },
    "subscribe_g": {
      "desc": "批量订阅",
      "label": "批量订阅"
    },
    "unsubscribe": {
      "desc": "取消订阅",
      "label": "取消订阅"
    },
    "unsubscribe_g": {
      "desc": "批量取消订阅",
      "label": "批量取消订阅"
    }
  },
  "emqx_mgmt_api_cluster": {
    "force_remove_node": {
      "desc": "强制节点离开集群",
      "label": "强制节点离开集群"
    },
    "get_cluster_info": {
      "desc": "获取集群信息",
      "label": "获取集群信息"
    },
    "get_cluster_topology": {
      "desc": "获取 RLOG 集群拓扑：核心节点与副本节点之间的连接。",
      "label": "获取集群拓扑"
    },
    "invite_node": {
      "desc": "邀请节点加入集群",
      "label": "邀请节点加入集群"
    }
  },
  "emqx_mgmt_api_configs": {
    "get_conf_node": {
      "desc": "获取节点的所有配置。包括热配置以及非热配置选项。",
      "label": "获取节点的所有配置"
    },
    "get_configs": {
      "desc": "获取指定键的所有配置，包括热更新和非热更新项目。",
      "label": "获取所有配置"
    },
    "get_global_zone_configs": {
      "desc": "获取全局默认 zone 的配置",
      "label": "获取全局默认 zone 的配置"
    },
    "get_node_level_limiter_configs": {
      "desc": "获取节点级的速率限制参数",
      "label": "获取节点级的速率限制参数"
    },
    "node_name": {
      "desc": "指定节点名称。如果未指定，则返回当前 HTTP 请求节点的配置。",
      "label": "节点名称"
    },
    "rest_conf_query": {
      "desc": "重置（使用 `conf_path` 参数）指定的配置路径下的值<br/>\n- 若指定路径的配置有默认值，则使用默认值；\n- 若指定路径的配置没有默认值，则返回 HTTP 状态码 400。",
      "label": "重置配置项"
    },
    "update_configs": {
      "desc": "更新指定建的配置。",
      "label": "更新配置"
    },
    "update_global_zone_configs": {
      "desc": "更新全局默认 zone 的配置",
      "label": "更新全局默认 zone 的配置"
    },
    "update_node_level_limiter_configs": {
      "desc": "更新节点级的速率限制参数",
      "label": "更新节点级的速率限制参数"
    }
  },
  "emqx_mgmt_api_key_schema": {
    "api_key": {
      "desc": "API 密钥， 可用于请求除管理 API 密钥及 Dashboard 用户管理 API 的其它接口",
      "label": "API 密钥"
    },
    "bootstrap_file": {
      "desc": "用于在启动 EMQX 时，添加 API 密钥，其格式为 {appid}:{secret}，多个密钥用换行分隔。：\n      ```\n      7e729ae70d23144b:2QILI9AcQ9BYlVqLDHQNWN2saIjBV4egr1CZneTNKr9CpK\n      ec3907f865805db0:Ee3taYltUKtoBVD9C3XjQl9C6NXheip8Z9B69BpUv5JxVHL\n      ```",
      "label": "API 密钥初始化文件"
    }
  },
  "emqx_mgmt_api_listeners": {
    "create_on_all_nodes": {
      "desc": "在所有节点上创建指定的监听器",
      "label": "创建监听器"
    },
    "delete_on_all_nodes": {
      "desc": "删除所有节点上指定 ID 的监听器",
      "label": "删除监听器"
    },
    "list_by_id": {
      "desc": "获取指定 ID 的监听器",
      "label": "获取指定 ID 的监听器"
    },
    "list_listeners": {
      "desc": "列出所有节点上的指定类型的监听器",
      "label": "列出监听器"
    },
    "list_node_live_statuses": {
      "desc": "列出所有节点上的监听器状态。按监听器类型分组",
      "label": "列出所有节点上的监听器状态"
    },
    "listener_type": {
      "desc": "监听器类型",
      "label": "监听器类型"
    },
    "restart_on_all_nodes": {
      "desc": "在所有节点上重启指定 ID 的监听器",
      "label": "重启监听器"
    },
    "start_on_all_nodes": {
      "desc": "在所有节点上启动指定 ID 的监听器",
      "label": "启动监听器"
    },
    "stop_on_all_nodes": {
      "desc": "在所有节点上停止指定 ID 的监听器",
      "label": "停止监听器"
    },
    "update_lisener": {
      "desc": "为集群中所有的节点更新指定 ID 的监听器",
      "label": "更新监听器"
    }
  },
  "emqx_mgmt_api_metrics": {
    "emqx_metrics": {
      "desc": "EMQX 监控指标信息",
      "label": "EMQX 监控指标信息"
    }
  },
  "emqx_mgmt_api_nodes": {
    "get_node_info": {
      "desc": "获取指定节点的详细信息。",
      "label": "获取指定节点信息"
    },
    "get_node_metrics": {
      "desc": "获取指定节点上的运行指标，例如消息发送数量，收到或发送字节数，认证和授权成功失败次数等。",
      "label": "获取指定节点运行指标"
    },
    "get_node_stats": {
      "desc": "获取指定节点上的统计信息，例如主题数量，连接数量等。",
      "label": "获取指定节点运行统计"
    },
    "list_nodes": {
      "desc": "获取当前集群下的节点列表。",
      "label": "获取节点列表"
    }
  },
  "emqx_mgmt_api_publish": {
    "error_message": {
      "desc": "失败的详细原因。"
    },
    "message_id": {
      "desc": "全局唯一的一个消息 ID，方便用于关联和追踪。"
    },
    "message_properties": {
      "desc": "PUBLISH 消息里的 Property 字段。"
    },
    "msg_content_type": {
      "desc": "消息内容类型必须是 UTF-8 编码的字符串。"
    },
    "msg_correlation_data": {
      "desc": "关联数据的标识符，服务器必须将关联数据原封不动地发送给接收应用消息的所有的订阅者。"
    },
    "msg_message_expiry_interval": {
      "desc": "消息过期间隔的标识符。如果消息过期间隔已过，而服务器未能开始向匹配的订阅者转发消息，则必须删除该订阅者的消息副本。"
    },
    "msg_payload_format_indicator": {
      "desc": "Payload 格式，0 (0x00) 字节表示是未指定格式的数据，相当于没有发送 Payload 格式指示；1 (0x01) 字节表示 Payload 是 UTF-8 编码的字符数据，Payload 中的 UTF-8 数据必须是按照 Unicode 的规范和 RFC 3629 的标准要求进行编码的。"
    },
    "msg_response_topic": {
      "desc": "响应主题的标识符。响应主题必须是 UTF-8 编码的，且不得包含通配符字符。"
    },
    "msg_user_properties": {
      "desc": "指定 MQTT 消息的 User Property 键值对。注意，如果出现重复的键，只有最后一个会保留。"
    },
    "payload": {
      "desc": "MQTT 消息体."
    },
    "payload_encoding": {
      "desc": "MQTT 消息体的编码方式，可以是 <code>base64</code> 或 <code>plain</code>。当设置为 <code>base64</code> 时，消息在发布前会先被解码，可以用于发布二进制等数据。"
    },
    "publish_api": {
      "desc": "发布单条信息。<br/>\n可能的 HTTP 状态码如下：<br/>\n200: 消息被成功发送到至少一个订阅。<br/>\n202: 没有匹配到任何订阅。<br/>\n400: 消息编码错误，如非法主题，或 QoS 超出范围等。<br/>\n503: 服务重启等过程中导致转发失败。",
      "label": "发布单条信息"
    },
    "publish_bulk_api": {
      "desc": "批量发布多条消息。<br/>\n可能的 HTTP 状态码如下：<br/>\n200: 所有的消息都被成功发送到至少一个订阅。<br/>\n202: 至少有一个消息没有匹配到任何订阅。<br/>\n400: 至少有一个消息编码错误，如非法主题，或 QoS 超出范围等。<br/>\n503: 至少有一个小因为服务重启的原因导致转发失败。<br/>\n\n请求的 Body 或者 Body 中包含的某个消息无法通过 API 规范的类型检查时，HTTP 响应的消息与发布单个消息的 API\n <code>/publish</code> 是一样的。\n如果所有的消息都是合法的，那么 HTTP 返回的内容是一个 JSON 数组，每个元素代表了该消息转发的状态。",
      "label": "批量发布多条消息"
    },
    "qos": {
      "desc": "QoS"
    },
    "reason_code": {
      "desc": "MQTT 消息发布的错误码，这些错误码也是 MQTT 规范中 PUBACK 消息可能携带的错误码。<br/>\n当前支持如下错误码：<br/>\n\n16(0x10)：没能匹配到任何订阅；<br/>\n131(0x81)：消息转发时发生错误，例如 EMQX 服务重启；<br/>\n144(0x90)：主题名称非法；<br/>\n151(0x97)：受到了速率限制，或者消息尺寸过大。全局消息大小限制可以通过配置项 <code>mqtt.max_packet_size</code> 来进行修改。<br/>\n注意：消息尺寸的是通过主题和消息体的字节数进行估算的，具体发布时所占用的字节数可能会稍大于这个估算的值。"
    },
    "retain": {
      "desc": "保留消息，布尔型字段，用于表示该消息是否是保留消息。"
    },
    "topic_name": {
      "desc": "主题"
    }
  },
  "emqx_mgmt_api_stats": {
    "emqx_stats": {
      "desc": "获取 EMQX 状态",
      "label": "获取 EMQX 状态"
    }
  },
  "emqx_mgmt_api_status": {
    "get_status_api": {
      "desc": "节点的健康检查 API，返回当前节点状态信息。\n\n如果 EMQX 应用程序已经启动并运行，返回状态代码 200，否则返回 503。\n\n这个 API 是在 v5.0.10 中引入的。GET `/status` 端点（没有 `/api/...` 前缀）也是这个端点的一个别名。 这个别名从 v5.0.0 开始就有了。自 v5.0.25 和 e5.0.4 开始，可以通过指定 'format' 参数来得到 JSON 格式的信息。",
      "label": "节点健康检查"
    },
    "get_status_api_format": {
      "desc": "指定返回的内容格式。使用 'text'（默认）则返回自由格式的字符串； 'json' 则返回 JSON 格式。"
    },
    "get_status_response200": {
      "desc": "如果 'format' 参数为 'json'，则返回如下 JSON：<br/>\n{\n  \"rel_vsn\": \"v5.0.23\",\n  \"node_name\": \"emqx@127.0.0.1\",\n  \"broker_status\": \"started\",\n  \"app_status\": \"running\"\n}\n<br/>\n否则返回 2 行自由格式的文本，第一行描述节点的状态，第二行描述 EMQX 应用运行状态。例如：<br/>\n\n```\nNode emqx@127.0.0.1 is started\nemqx is running\n```\n"
    },
    "get_status_response503": {
      "desc": "如果 EMQX 应用暂时没有启动，或正在重启，则可能返回 'emqx is not_running'"
    }
  },
  "emqx_mgmt_api_subscriptions": {
    "list_subs": {
      "desc": "获取集群的订阅列表。",
      "label": "获取订阅列表"
    }
  },
  "emqx_mgmt_api_topics": {
    "topic_info_by_name": {
      "desc": "根据主题名获取主题列表",
      "label": "根据主题名获取主题列表"
    },
    "topic_list": {
      "desc": "获取集群的主题列表，主题列表根据订阅关系生成。",
      "label": "获取主题列表"
    }
  },
  "emqx_mgmt_api_trace": {
    "clear_all": {
      "desc": "清除所有 trace",
      "label": "清除所有 trace"
    },
    "client_ip_addess": {
      "desc": "如果过滤器类型为 'ip_address' 则该字段可以指定用于匹配的客户端 IP 地址。",
      "label": "客户端 IP 地址"
    },
    "create_new": {
      "desc": "创建 trace",
      "label": "创建 trace"
    },
    "current_trace_offset": {
      "desc": "指定从该偏移量开始读取指定的 trace 日志文件。",
      "label": "读取偏移量"
    },
    "delete_trace": {
      "desc": "删除指定的 trace",
      "label": "删除 trace"
    },
    "download_log_by_name": {
      "desc": "下载指定 trace 的日志文件",
      "label": "下载 trace"
    },
    "file_mtime": {
      "desc": "此文件最后一次修改的时间。",
      "label": "文件修改时间"
    },
    "file_size": {
      "desc": "文件大小",
      "label": "文件大小"
    },
    "filter_type": {
      "desc": "过滤器类型",
      "label": "过滤器类型"
    },
    "format": {
      "desc": "唯一的名称。只允许使用 a-z，A-Z，0-9 和 下划线（‘_’）这些字符。",
      "label": "Trace 名称"
    },
    "get_trace_file_metadata": {
      "desc": "获取 trace 日志文件的元数据, 例如文件大小和修改时间",
      "label": "获取 trace 信息"
    },
    "list_all": {
      "desc": "列出所有 trace",
      "label": "列出 trace"
    },
    "max_response_bytes": {
      "desc": "单个 HTTP 相应中包含 trace 日志的字节数。",
      "label": "响应字节数"
    },
    "modification_date": {
      "desc": "文件最后修改时间",
      "label": "文件最后修改时间"
    },
    "mqtt_clientid": {
      "desc": "如果过滤器类型为 'clientid' 则该字段可以指定用于匹配的 MQTT 客户端 ID。",
      "label": "MQTT 客户端 ID"
    },
    "node_name": {
      "desc": "指定从哪个节点获取 trace 文件内容。",
      "label": "节点名称"
    },
    "stop_trace": {
      "desc": "停止指定的 trace",
      "label": "停止 trace"
    },
    "support_wildcard": {
      "desc": "如果过滤器类型为 'topic' 则该字段可以指定用于匹配的 MQTT 主题或主题过滤器。",
      "label": "MQTT 主题或主题过滤器"
    },
    "time_format": {
      "desc": "rfc3339 或者 epoch 时间戳格式",
      "label": "rfc3339 或者 epoch 时间戳格式"
    },
    "time_format_g": {
      "desc": "rfc3339 或者 epoch 时间戳格式",
      "label": "时间格式"
    },
    "trace_log_size": {
      "desc": "日志文件大小",
      "label": "日志文件大小"
    },
    "trace_name": {
      "desc": "日志追踪的唯一名字。只允许使用小写字母 a-z、大写字母 A-Z、数字 0-9 和下划线 '_'。",
      "label": "日志追踪唯一名字"
    },
    "trace_status": {
      "desc": "Trace 状态",
      "label": "Trace 状态"
    },
    "trace_zip_file": {
      "desc": "包含 trace 日志的 zip 压缩文件",
      "label": "压缩文件"
    },
    "view_trace_log": {
      "desc": "查看 trace",
      "label": "查看 trace"
    }
  },
  "emqx_modules_schema": {
    "enable": {
      "desc": "是否启用"
    },
    "max_delayed_messages": {
      "desc": "延迟消息的数量上限(0 代表不限数量)"
    },
    "rewrite": {
      "desc": "EMQX 的主题重写功能支持根据用户配置的规则在客户端订阅主题、发布消息、取消订阅的时候将 A 主题重写为 B 主题。\n重写规则分为 Pub 规则和 Sub 规则，Pub 规则匹配 PUSHLISH 报文携带的主题，Sub 规则匹配 SUBSCRIBE、UNSUBSCRIBE 报文携带的主题。\n每条重写规则都由主题过滤器、正则表达式、目标表达式三部分组成。\n在主题重写功能开启的前提下，EMQX 在收到诸如 PUBLISH 报文等带有主题的 MQTT 报文时，将使用报文中的主题去依次匹配配置文件中规则的主题过滤器部分，一旦成功匹配，则使用正则表达式提取主题中的信息，然后替换至目标表达式以构成新的主题。\n目标表达式中可以使用 `$N` 这种格式的变量匹配正则表达中提取出来的元素，`$N` 的值为正则表达式中提取出来的第 N 个元素，比如 `$1` 即为正则表达式提取的第一个元素。\n需要注意的是，EMQX 使用倒序读取配置文件中的重写规则，当一条主题可以同时匹配多条主题重写规则的主题过滤器时，EMQX 仅会使用它匹配到的第一条规则进行重写，如果该条规则中的正则表达式与 MQTT 报文主题不匹配，则重写失败，不会再尝试使用其他的规则进行重写。\n因此用户在使用时需要谨慎的设计 MQTT 报文主题以及主题重写规则。",
      "label": "主题重写"
    },
    "tr_action": {
      "desc": "主题重写在哪种操作上生效：\n  - `subscribe`：订阅时重写主题；\n  - `publish`：发布时重写主题；\n  - `all`：在发布与订阅时重写主题",
      "label": "重写动作"
    },
    "tr_dest_topic": {
      "desc": "目标主题。",
      "label": "目标主题"
    },
    "tr_re": {
      "desc": "正则表达式"
    },
    "tr_source_topic": {
      "desc": "源主题，客户端业务指定的主题",
      "label": "源主题"
    }
  },
  "emqx_mongodb": {
    "use_legacy_protocol": {
      "desc": "是否使用 MongoDB 的传统协议与数据库通信。默认情况下，将尝试自动确定是否支持较新的协议。",
      "label": "使用传统协议"
    }
  },
  "emqx_mqttsn_schema": {
    "mqttsn": {
      "desc": "MQTT-SN 网关配置。当前实现仅支持 v1.2 版本"
    },
    "mqttsn_broadcast": {
      "desc": "是否周期性广播 ADVERTISE 消息"
    },
    "mqttsn_enable_qos3": {
      "desc": "是否允许无连接的客户端发送 QoS 等于 -1 的消息。\n该功能主要用于支持轻量的 MQTT-SN 客户端实现，它不会向网关建立连接，注册主题，也不会发起订阅；它只使用 QoS 为 -1 来发布消息"
    },
    "mqttsn_gateway_id": {
      "desc": "MQTT-SN 网关 ID。\n当 <code>broadcast</code> 打开时，MQTT-SN 网关会使用该 ID 来广播 ADVERTISE 消息"
    },
    "mqttsn_predefined": {
      "desc": "预定义主题列表。\n预定义的主题列表，是一组 主题 ID 和 主题名称 的映射关系。使用预先定义的主题列表，可以减少 MQTT-SN 客户端和网关对于固定主题的注册请求"
    },
    "mqttsn_predefined_id": {
      "desc": "主题 ID。范围：1-65535"
    },
    "mqttsn_predefined_topic": {
      "desc": "主题名称。注：不支持通配符"
    },
    "mqttsn_subs_resume": {
      "desc": "在会话被重用后，网关是否主动向客户端注册对已订阅主题名称"
    }
  },
  "emqx_node_rebalance_api": {
    "abs_conn_threshold": {
      "desc": "当前节点上的连接数与迁入节点上的平均连接数的最大期望差值，低于此比例是重平衡过程的目的。",
      "label": "连接数差值"
    },
    "abs_sess_threshold": {
      "desc": "当前节点上的会话数与迁入节点上的平均会话数之间的最大期望差值，低于此比例是节点疏散过程的目的。",
      "label": "会话数差值"
    },
    "cluster_purge_start": {
      "desc": "开始清除进程",
      "label": "开始清除"
    },
    "cluster_purge_stop": {
      "desc": "停止清除进程",
      "label": "停止清除"
    },
    "conn_evict_rate": {
      "desc": "每秒迁出连接数",
      "label": "迁出速率"
    },
    "coordinator_status_donor_conn_avg": {
      "desc": "每个迁出节点的平均连接数",
      "label": "迁出节点连接平均值"
    },
    "coordinator_status_donor_sess_avg": {
      "desc": "每个迁出节点的平均会话数",
      "label": "迁出节点会话平均数"
    },
    "coordinator_status_donors": {
      "desc": "正在迁出连接/会话的节点列表",
      "label": "迁出节点"
    },
    "coordinator_status_node": {
      "desc": "协调分配疏散/重平衡任务的节点",
      "label": "协调节点"
    },
    "empty_response": {
      "desc": "响应为空",
      "label": "空响应"
    },
    "evacuation_status_node": {
      "desc": "正在迁出的节点",
      "label": "疏散节点"
    },
    "global_status_evacuations": {
      "desc": "正在迁出的节点列表",
      "label": "疏散"
    },
    "global_status_rebalances": {
      "desc": "协调重平衡的节点列表",
      "label": "重平衡"
    },
    "load_rebalance_availability_check": {
      "desc": "检查节点是否正在被执行重平衡或疏散",
      "label": "可用性检查"
    },
    "load_rebalance_evacuation_start": {
      "desc": "启动疏散任务",
      "label": "启动疏散"
    },
    "load_rebalance_evacuation_stop": {
      "desc": "停止疏散任务",
      "label": "停止疏散"
    },
    "load_rebalance_global_status": {
      "desc": "获取集群中所有重平衡/疏散任务的状态",
      "label": "获取全局重平衡状态"
    },
    "load_rebalance_start": {
      "desc": "启动重平衡任务",
      "label": "启动重平衡"
    },
    "load_rebalance_status": {
      "desc": "获取当前节点的重平衡状态",
      "label": "获取重平衡状态"
    },
    "load_rebalance_stop": {
      "desc": "停止重平衡任务",
      "label": "停止重平衡"
    },
    "local_status_connection_eviction_rate": {
      "desc": "每秒迁出的连接数",
      "label": "连接迁出速率"
    },
    "local_status_connection_goal": {
      "desc": "节点在重新平衡/疏散任务完成后预期拥有的连接数",
      "label": "连接数目标"
    },
    "local_status_coordinator_node": {
      "desc": "协调分配重平衡任务的节点",
      "label": "协调节点"
    },
    "local_status_disconnected_session_goal": {
      "desc": "重新平衡任务完成后节点预期的无连接的会话数",
      "label": "预期无连接会话数"
    },
    "local_status_enabled": {
      "desc": "节点是否正在执行重平衡疏散任务",
      "label": "运行状态"
    },
    "local_status_process": {
      "desc": "正在节点上执行的任务：'evacuation' 或 'rebalance'",
      "label": "节点任务"
    },
    "local_status_purge_rate": {
      "desc": "会话清除速率，以每秒会话数为单位",
      "label": "会话清除速率"
    },
    "local_status_recipients": {
      "desc": "在重新平衡期间接受连接/会话迁入的节点列表",
      "label": "接受迁入节点"
    },
    "local_status_session_eviction_rate": {
      "desc": "每秒迁出的会话数",
      "label": "会话迁出速率"
    },
    "local_status_session_goal": {
      "desc": "疏散任务完成后节点预期的会话数",
      "label": "会话数目标"
    },
    "local_status_session_recipients": {
      "desc": "会话被迁入的节点列表",
      "label": "会话迁入节点"
    },
    "local_status_state": {
      "desc": "正在节点上执行的任务的状态",
      "label": "重新平衡/疏散当前状态"
    },
    "local_status_stats": {
      "desc": "疏散/重平衡的统计",
      "label": "统计数据"
    },
    "migrate_to": {
      "desc": "接受会话迁入的节点",
      "label": "迁入节点"
    },
    "param_node": {
      "desc": "节点名称",
      "label": "节点名称"
    },
    "rebalance_nodes": {
      "desc": "参与重平衡的节点",
      "label": "重新平衡节点"
    },
    "redirect_to": {
      "desc": "将客户端重定向到的服务器参考（MQTTv5 服务器重定向）",
      "label": "重定向至"
    },
    "rel_conn_threshold": {
      "desc": "当前节点上的连接数与迁入节点上的平均连接数的最大期望比值，低于该比值时停止重平衡。",
      "label": "连接数比值"
    },
    "rel_sess_threshold": {
      "desc": "当前节点上的会话数与迁入节点上的平均会话数的比值上限，低于该比值时停止迁移会话。",
      "label": "会话数比值"
    },
    "sess_evict_rate": {
      "desc": "每秒迁出会话数",
      "label": "会话迁出速率"
    },
    "status_stats_current_connected": {
      "desc": "节点上的当前连接数",
      "label": "当前连接"
    },
    "status_stats_current_disconnected_sessions": {
      "desc": "节点上当前无连接的会话数",
      "label": "当前无连接会话"
    },
    "status_stats_current_sessions": {
      "desc": "节点上的当前会话数",
      "label": "当前会话"
    },
    "status_stats_initial_connected": {
      "desc": "疏散/重新平衡任务开始之前节点上的连接数",
      "label": "初始连接"
    },
    "status_stats_initial_sessions": {
      "desc": "疏散/重新平衡任务开始之前节点上的会话数",
      "label": "初始会话"
    },
    "wait_health_check": {
      "desc": "启动重平衡任务前等待的时间，单位为秒",
      "label": "等待健康检查"
    },
    "wait_takeover": {
      "desc": "开始会话疏散任务之前的等待时间，以秒为单位",
      "label": "等待接管"
    }
  },
  "emqx_oracle": {
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>主机名具有以下形式：`Host[:Port]`。<br/>如果未指定 `[:Port]`，则使用 Oracle Database 默认端口 1521。",
      "label": "服务器地址"
    },
    "service_name": {
      "desc": "Oracle Database 服务名称。",
      "label": "Oracle Database 服务名称"
    },
    "sid": {
      "desc": "Oracle Database Sid 名称",
      "label": "Oracle Database Sid"
    }
  },
  "emqx_otel_schema": {
    "enable": {
      "desc": "启用或禁用 open telemetry 指标"
    },
    "endpoint": {
      "desc": "Open Telemetry 导出端点"
    },
    "exporter": {
      "desc": "Open Telemetry 导出"
    },
    "interval": {
      "desc": "发送指标到 Open Telemetry 端点的时间间隔"
    },
    "opentelemetry": {
      "desc": "Open Telemetry 工具包配置"
    },
    "protocol": {
      "desc": "Open Telemetry 导出协议"
    }
  },
  "emqx_plugins_schema": {
    "check_interval": {
      "desc": "检查间隔：检查集群中插件的状态是否一致，<br/>\n如果连续 3 次检查结果不一致，则报警。"
    },
    "enable": {
      "desc": "设置为“true”以启用此插件。",
      "label": "启用"
    },
    "install_dir": {
      "desc": "插件安装包的目录，出于安全考虑，该目录应该值允许 <code>emqx</code>，或用于运行 EMQX 服务的用户拥有写入权限。",
      "label": "安装目录"
    },
    "name_vsn": {
      "desc": "插件的名称{name}-{version}。<br/>\n它应该与插件的发布包名称一致，如 my_plugin-0.1.0。",
      "label": "名称-版本"
    },
    "plugins": {
      "desc": "管理 EMQX 插件。<br/>\n插件可以是 EMQX 安装包中的一部分，也可以是一个独立的安装包。<br/>\n独立安装的插件称为“外部插件”。",
      "label": "插件"
    },
    "state": {
      "desc": "描述插件的状态",
      "label": "插件状态"
    },
    "states": {
      "desc": "一组插件的状态。插件将按照定义的顺序启动",
      "label": "插件启动顺序及状态"
    }
  },
  "emqx_postgresql": {
    "server": {
      "desc": "要连接的 IPv4 或 IPv6 地址或主机名。<br/>\n一个主机条目的格式为：Host[:Port]。<br/>\n如果没有指定 [:Port]，将使用 PostgreSQL 默认端口 5432。",
      "label": "服务器主机"
    }
  },
  "emqx_prometheus_api": {
    "get_prom_conf_info": {
      "desc": "Get Prometheus config info",
      "label": "Get Prometheus config info"
    },
    "get_prom_data": {
      "desc": "Get Prometheus Data",
      "label": "Get Prometheus Data"
    },
    "update_prom_conf_info": {
      "desc": "Update Prometheus config",
      "label": "Update Prometheus config"
    }
  },
  "emqx_prometheus_schema": {
    "enable": {
      "desc": "开启或关闭 Prometheus 数据推送"
    },
    "headers": {
      "desc": "推送到 Push Gateway 的 HTTP Headers 列表。<br/>\n例如，<code> { Authorization = \"some-authz-tokens\"}</code>"
    },
    "interval": {
      "desc": "数据推送间隔"
    },
    "job_name": {
      "desc": "推送到 Push Gateway 的 Job 名称。可用变量为：<br/>\n- ${name}: EMQX 节点的名称。\n- ${host}: EMQX 节点主机名。\n例如，当 EMQX 节点名为 <code>emqx@127.0.0.1</code> 则 name 变量的值为 <code>emqx</code>，host 变量的值为 <code>127.0.0.1</code>。<br/>\n默认值为: <code>${name}/instance/${name}~${host}</code>"
    },
    "mnesia_collector": {
      "desc": "开启或关闭 Mnesia 采集器, 使用 mnesia:system_info/1 收集 Mnesia 相关指标"
    },
    "prometheus": {
      "desc": "Prometheus 监控数据推送",
      "label": "Prometheus"
    },
    "push_gateway_server": {
      "desc": "Prometheus 服务器地址"
    },
    "vm_dist_collector": {
      "desc": "开启或关闭 VM 分布采集器，收集 Erlang 分布机制中涉及的套接字和进程的信息。"
    },
    "vm_memory_collector": {
      "desc": "开启或关闭 VM 内存采集器, 使用 erlang:memory/0 收集 Erlang 虚拟机动态分配的内存信息，同时提供基本的 (D)ETS 统计信息"
    },
    "vm_msacc_collector": {
      "desc": "开启或关闭 VM msacc 采集器, 使用 erlang:statistics(microstate_accounting) 收集微状态计数指标"
    },
    "vm_statistics_collector": {
      "desc": "开启或关闭 VM 统计采集器, 使用 erlang:statistics/1 收集 Erlang VM 相关指标"
    },
    "vm_system_info_collector": {
      "desc": "开启或关闭 VM 系统信息采集器, 使用 erlang:system_info/1 收集 Erlang VM 相关指标"
    }
  },
  "emqx_psk_schema": {
    "chunk_size": {
      "desc": "将 PSK 文件导入到内建数据时每个块的大小"
    },
    "enable": {
      "desc": "是否开启 TLS PSK 支持"
    },
    "init_file": {
      "desc": "如果设置了初始化文件，EMQX 将在启动时从初始化文件中导入 PSK 信息到内建数据库中。\n这个文件需要按行进行组织，每一行必须遵守如下格式: <code>PSKIdentity:SharedSecret</code>\n例如: <code>mydevice1:c2VjcmV0</code>"
    },
    "psk_authentication": {
      "desc": "此配置用于启用 TLS-PSK 身份验证。\n\nPSK 是 “Pre-Shared-Keys” 的缩写。\n\n注意: 确保 SSL 监听器仅启用了 'tlsv1.2'，并且配置了 PSK 密码套件，例如 'RSA-PSK-AES256-GCM-SHA384'。\n\n可以通过查看监听器中的 SSL 选项，了解更多详细信息。\n\n可以通过配置 'init_file' 来设置初始化的 ID 和 密钥"
    },
    "separator": {
      "desc": "PSK 文件中 <code>PSKIdentity</code> 和 <code>SharedSecret</code> 之间的分隔符"
    }
  },
  "emqx_resource_schema": {
    "auto_restart_interval": {
      "desc": "资源断开以后，自动重连的时间间隔。",
      "label": "自动重连间隔"
    },
    "batch_size": {
      "desc": "最大批量请求大小。如果设为 1，则无批处理。",
      "label": "最大批量请求大小"
    },
    "batch_time": {
      "desc": "在较低消息率情况下尝试累积批量输出时的最大等待间隔，以提高资源的利用率。",
      "label": "批量等待最大间隔"
    },
    "buffer_mode": {
      "desc": "队列操作模式。\n<code>memory_only</code>: 所有的消息都缓存在内存里。<code>volatile_offload</code>: 先将消息缓存在内存中，当内存中的消息堆积超过一定限制（配置项 <code>buffer_seg_bytes</code> 指定该限制）后， 消息会开始缓存到磁盘上。",
      "label": "缓存模式"
    },
    "buffer_seg_bytes": {
      "desc": "当缓存模式是 <code>volatile_offload</code> 时适用。该配置用于指定缓存到磁盘上的文件的大小。",
      "label": "缓存文件大小"
    },
    "creation_opts": {
      "desc": "资源启动相关的选项。",
      "label": "资源启动选项"
    },
    "enable_batch": {
      "desc": "启用批量模式。",
      "label": "启用批量模式"
    },
    "enable_queue": {
      "desc": "启用磁盘缓存队列（仅对 egress 方向桥接有用）。",
      "label": "启用磁盘缓存队列"
    },
    "health_check_interval": {
      "desc": "健康检查间隔。",
      "label": "健康检查间隔"
    },
    "inflight_window": {
      "desc": "请求飞行队列窗口大小。当请求模式为异步时，如果需要严格保证来自同一 MQTT 客户端的消息有序，则必须将此值设为 1。",
      "label": "请求飞行队列窗口"
    },
    "max_buffer_bytes": {
      "desc": "每个缓存 worker 允许使用的最大字节数。",
      "label": "缓存队列最大长度"
    },
    "query_mode": {
      "desc": "请求模式。可选 '同步/异步'，默认为'异步'模式。",
      "label": "请求模式"
    },
    "request_timeout": {
      "desc": "从请求进入缓冲区开始计时，如果请求在规定的时间内仍停留在缓冲区内或者已发送但未能及时收到响应或确认，该请求将被视为过期。",
      "label": "请求超期"
    },
    "request_ttl": {
      "desc": "从请求进入缓冲区的时刻开始，如果请求在指定的时间内仍然停留在缓冲区中，或者已经发送但没有及时收到响应或确认，该请求将被视为过期。",
      "label": "请求 TTL（生存时间）"
    },
    "resource_opts": {
      "desc": "资源相关的选项。",
      "label": "资源选项"
    },
    "resume_interval": {
      "desc": "在发送失败后尝试重传飞行窗口中的请求的时间间隔。",
      "label": "重试时间间隔"
    },
    "start_after_created": {
      "desc": "是否在创建资源后立即启动资源。",
      "label": "创建后立即启动"
    },
    "start_timeout": {
      "desc": "在回复资源创建请求前等待资源进入健康状态的时间。",
      "label": "启动超时时间"
    },
    "worker_pool_size": {
      "desc": "缓存队列 worker 数量。仅对 egress 类型的桥接有意义。当桥接仅有 ingress 方向时，可设置为 0，否则必须大于 0。",
      "label": "缓存池大小"
    }
  },
  "emqx_retainer_api": {
    "config_content": {
      "desc": "配置内容"
    },
    "config_not_found": {
      "desc": "配置不存在"
    },
    "delete_matching_api": {
      "desc": "删除对应的消息",
      "label": "删除对应的消息"
    },
    "from_clientid": {
      "desc": "发布者客户端 ID"
    },
    "from_username": {
      "desc": "发布者用户名"
    },
    "get_config_api": {
      "desc": "查看配置内容",
      "label": "查看配置内容"
    },
    "list_retained_api": {
      "desc": "查看保留消息列表",
      "label": "查看保留消息列表"
    },
    "lookup_api": {
      "desc": "不支持主题通配符",
      "label": "指定主题查看保留消息"
    },
    "message_detail": {
      "desc": "消息详情"
    },
    "message_not_exist": {
      "desc": "消息不存在"
    },
    "msgid": {
      "desc": "消息 ID"
    },
    "payload": {
      "desc": "消息内容"
    },
    "publish_at": {
      "desc": "消息发送时间, RFC 3339 格式"
    },
    "qos": {
      "desc": "QoS"
    },
    "retained_list": {
      "desc": "保留消息列表"
    },
    "topic": {
      "desc": "主题"
    },
    "unsupported_backend": {
      "desc": "不支持的后端"
    },
    "update_config_failed": {
      "desc": "配置更新失败"
    },
    "update_config_success": {
      "desc": "配置更新成功"
    },
    "update_retainer_api": {
      "desc": "更新配置",
      "label": "更新配置"
    }
  },
  "emqx_retainer_schema": {
    "backend": {
      "desc": "保留消息的存储后端"
    },
    "batch_deliver_limiter": {
      "desc": "批量发送的限流器的名称。\n限流器可以用来防止短时间内向客户端发送太多的消息，从而避免过多的消息导致客户端队列堵塞甚至崩溃。\n这个名称需要是指向 `limiter.batch` 下的一个真实存在的限流器。\n如果这个字段为空，则不使用限流器。"
    },
    "batch_deliver_number": {
      "desc": "批量派发时每批的数量。0 代表一次性全部派发"
    },
    "batch_read_number": {
      "desc": "从存储后端批量加载时的每批数量上限，0 代表一次性读取"
    },
    "delivery_rate": {
      "desc": "发送保留消息的最大速率"
    },
    "enable": {
      "desc": "是否开启消息保留功能"
    },
    "flow_control": {
      "desc": "流控设置"
    },
    "max_payload_size": {
      "desc": "消息大小最大值"
    },
    "max_retained_messages": {
      "desc": "消息保留的数量上限。0 表示无限"
    },
    "mnesia_config_storage_type": {
      "desc": "选择消息是存放在磁盘还是内存中"
    },
    "mnesia_config_type": {
      "desc": "后端类型"
    },
    "msg_clear_interval": {
      "desc": "消息清理间隔。0 代表不进行清理"
    },
    "msg_expiry_interval": {
      "desc": "消息保留时间。0 代表永久保留"
    },
    "stop_publish_clear_msg": {
      "desc": "当 PUBLISH 消息的保留标志被设置且有效载荷为空时，是否继续发布消息。\n参见：\nhttp://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038"
    }
  },
  "emqx_rewrite_api": {
    "list_topic_rewrite_api": {
      "desc": "列出全部主题重写规则",
      "label": "列出全部主题重写规则"
    },
    "update_topic_rewrite_api": {
      "desc": "更新全部主题重写规则",
      "label": "更新全部主题重写规则"
    },
    "update_topic_rewrite_api_response400": {
      "desc": "----",
      "label": "错误的请求"
    },
    "update_topic_rewrite_api_response413": {
      "desc": "超出主题重写规则数量上限",
      "label": "超出主题重写规则数量上限"
    }
  },
  "emqx_rule_api_schema": {
    "event_action": {
      "desc": "订阅或发布",
      "label": "订阅或发布"
    },
    "event_authz_source": {
      "desc": "缓存，插件或者默认值",
      "label": "认证源"
    },
    "event_clean_start": {
      "desc": "清除会话",
      "label": "清除会话"
    },
    "event_clientid": {
      "desc": "客户端 ID",
      "label": "客户端 ID"
    },
    "event_connected_at": {
      "desc": "客户端连接完成时的时刻",
      "label": "连接完成时的时刻"
    },
    "event_ctx_connack_reason_code": {
      "desc": "错误码",
      "label": "错误码"
    },
    "event_ctx_disconnected_da": {
      "desc": "客户端断开连接的时刻",
      "label": "客户端断开连接时刻"
    },
    "event_ctx_disconnected_reason": {
      "desc": "断开连接的原因",
      "label": "断开连接原因"
    },
    "event_ctx_dropped": {
      "desc": "消息被丢弃的原因",
      "label": "丢弃原因"
    },
    "event_dup": {
      "desc": "MQTT 消息的 DUP 标志",
      "label": "DUP 标志"
    },
    "event_event_type": {
      "desc": "事件类型",
      "label": "事件类型"
    },
    "event_expiry_interval": {
      "desc": "到期间隔",
      "label": "到期间隔"
    },
    "event_from_clientid": {
      "desc": "事件来源客户端的 ID",
      "label": "客户端 ID"
    },
    "event_from_username": {
      "desc": "事件来源客户端的用户名",
      "label": "用户名"
    },
    "event_id": {
      "desc": "消息 ID",
      "label": "消息 ID"
    },
    "event_is_bridge": {
      "desc": "是否桥接",
      "label": "是否桥接"
    },
    "event_keepalive": {
      "desc": "保持连接",
      "label": "保持连接"
    },
    "event_mountpoint": {
      "desc": "挂载点",
      "label": "挂载点"
    },
    "event_payload": {
      "desc": "消息负载",
      "label": "消息负载"
    },
    "event_peerhost": {
      "desc": "对等客户端的 IP 地址",
      "label": "对等客户端的 IP"
    },
    "event_peername": {
      "desc": "对等客户端的 IP 地址和端口",
      "label": "IP 地址和端口"
    },
    "event_proto_name": {
      "desc": "协议名称",
      "label": "协议名称"
    },
    "event_proto_ver": {
      "desc": "协议版本",
      "label": "协议版本"
    },
    "event_publish_received_at": {
      "desc": "消息被接受的时间",
      "label": "消息被接受的时间"
    },
    "event_qos": {
      "desc": "消息的 QoS",
      "label": "消息 QoS"
    },
    "event_result": {
      "desc": "允许或禁止",
      "label": "认证结果"
    },
    "event_retain": {
      "desc": "是否是保留消息",
      "label": "保留消息"
    },
    "event_server": {
      "desc": "MQTT broker 的 IP 地址（或主机名）和端口，采用 IP:Port 格式",
      "label": "服务器 IP 地址和端口"
    },
    "event_sockname": {
      "desc": "本地监听的 IP 地址和端口",
      "label": "IP 地址和端口"
    },
    "event_topic": {
      "desc": "消息主题",
      "label": "消息主题"
    },
    "event_username": {
      "desc": "用户名",
      "label": "用户名"
    },
    "metrics_actions_failed": {
      "desc": "规则调用输出失败的次数。",
      "label": "调用输出失败次数"
    },
    "metrics_actions_failed_out_of_service": {
      "desc": "由于输出停止服务而导致规则调用输出失败的次数。 例如，桥接被禁用或停止。",
      "label": "调用输出失败次数"
    },
    "metrics_actions_failed_unknown": {
      "desc": "由于未知错误，规则调用输出失败的次数。",
      "label": "调用输出失败次数"
    },
    "metrics_actions_success": {
      "desc": "规则成功调用输出的次数。",
      "label": "成功调用输出次数"
    },
    "metrics_actions_total": {
      "desc": "规则调用输出的次数。 该值可能是“sql.matched”的几倍，具体取决于规则输出的数量。",
      "label": "调用输出次数"
    },
    "metrics_sql_failed": {
      "desc": "SQL 失败的次数",
      "label": "SQL 失败"
    },
    "metrics_sql_failed_exception": {
      "desc": "SQL 由于执行异常而失败的次数。 这可能是因为调用 SQL 函数时崩溃，或者试图对未定义的变量进行算术运算。",
      "label": "SQL 执行异常"
    },
    "metrics_sql_failed_unknown": {
      "desc": "由于未知错误导致 SQL 失败的次数。",
      "label": "SQL 未知错误"
    },
    "metrics_sql_matched": {
      "desc": "SQL 的 FROM 子句匹配的次数。",
      "label": "命中数"
    },
    "metrics_sql_matched_rate": {
      "desc": "命中速率，次/秒",
      "label": "Matched Rate"
    },
    "metrics_sql_matched_rate_last5m": {
      "desc": "5 分钟平均命中速率，次/秒",
      "label": "平均命中速率"
    },
    "metrics_sql_matched_rate_max": {
      "desc": "最大命中速率，次/秒",
      "label": "最大命中速率"
    },
    "metrics_sql_passed": {
      "desc": "SQL 通过的次数",
      "label": "SQL 通过"
    },
    "node_node": {
      "desc": "节点名字",
      "label": "节点名字"
    },
    "ri_created_at": {
      "desc": "规则创建时间",
      "label": "规则创建时间"
    },
    "ri_from": {
      "desc": "规则指定的主题",
      "label": "规则指定的主题"
    },
    "ri_metrics": {
      "desc": "规则的计数器",
      "label": "规则计数器"
    },
    "ri_node_metrics": {
      "desc": "每个节点的规则计数器",
      "label": "每个节点规则计数器"
    },
    "root_rule_creation": {
      "desc": "用于创建规则的 Schema",
      "label": "用于创建规则的 Schema"
    },
    "root_rule_engine": {
      "desc": "规则引擎配置。该 API 可用于查看和修改规则引擎相关的一些设置。但不可用于规则，如需查看或修改规则，请调用 '/rules' API 进行操作。",
      "label": "规则引擎配置"
    },
    "root_rule_events": {
      "desc": "用于事件的 Schema",
      "label": "用于规则事件的 Schema"
    },
    "root_rule_info": {
      "desc": "用于规则信息的 Schema",
      "label": "用于规则信息的 Schema"
    },
    "root_rule_test": {
      "desc": "用于规则测试的 Schema",
      "label": "用于规则测试的 Schema"
    },
    "rs_columns": {
      "desc": "列",
      "label": "列"
    },
    "rs_description": {
      "desc": "描述",
      "label": "描述"
    },
    "rs_event": {
      "desc": "事件主题",
      "label": "事件主题"
    },
    "rs_sql_example": {
      "desc": "SQL 示例",
      "label": "SQL 示例"
    },
    "rs_test_columns": {
      "desc": "测试列",
      "label": "测试列"
    },
    "rs_title": {
      "desc": "标题",
      "label": "标题"
    },
    "rule_id": {
      "desc": "规则的 ID",
      "label": "规则 ID"
    },
    "test_context": {
      "desc": "测试事件的上下文",
      "label": "事件上下文"
    },
    "test_sql": {
      "desc": "测试的 SQL",
      "label": "测试 SQL"
    }
  },
  "emqx_rule_engine_api": {
    "api1": {
      "desc": "列出所有规则",
      "label": "列出所有规则"
    },
    "api10": {
      "desc": "更新规则引擎配置。",
      "label": "更新配置"
    },
    "api1_enable": {
      "desc": "根据规则是否开启条件过滤"
    },
    "api1_from": {
      "desc": "根据规则来源 Topic 过滤, 需要完全匹配"
    },
    "api1_like_description": {
      "desc": "根据规则描述过滤, 使用子串模糊匹配"
    },
    "api1_like_from": {
      "desc": "根据规则来源 Topic 过滤, 使用子串模糊匹配"
    },
    "api1_like_id": {
      "desc": "根据规则 id 过滤, 使用子串模糊匹配"
    },
    "api1_match_from": {
      "desc": "根据规则来源 Topic 过滤, 使用 MQTT Topic 匹配"
    },
    "api1_resp": {
      "desc": "规则列表",
      "label": "列出所有规则"
    },
    "api2": {
      "desc": "通过指定 ID 创建规则",
      "label": "通过指定 ID 创建规则"
    },
    "api3": {
      "desc": "列出所有能被规则使用的事件",
      "label": "列出所有能被规则使用的事件"
    },
    "api4": {
      "desc": "通过 ID 查询规则",
      "label": "查询规则"
    },
    "api4_1": {
      "desc": "通过给定的 Id 获得规则的指标数据",
      "label": "获得指标数据"
    },
    "api5": {
      "desc": "通过 ID 更新集群里所有节点上的规则",
      "label": "更新集群规则"
    },
    "api6": {
      "desc": "通过 ID 删除集群里所有节点上的规则",
      "label": "基于给定 ID 新建一条规则"
    },
    "api7": {
      "desc": "重置规则计数",
      "label": "重置规则计数"
    },
    "api8": {
      "desc": "测试一个规则",
      "label": "测试规则"
    },
    "api9": {
      "desc": "获取规则引擎配置。",
      "label": "获取配置"
    }
  },
  "emqx_rule_engine_schema": {
    "console_function": {
      "desc": "将输出打印到控制台",
      "label": "控制台函数"
    },
    "desc_builtin_action_console": {
      "desc": "配置打印到控制台",
      "label": "配置打印到控制台"
    },
    "desc_builtin_action_republish": {
      "desc": "配置重新发布。",
      "label": "配置重新发布"
    },
    "desc_republish_args": {
      "desc": "内置 'republish' 动作的参数。\n可以在参数中使用变量。\n变量是规则中选择的字段。 例如规则 SQL 定义如下：\n<code>\n    SELECT clientid, qos, payload FROM \"t/1\"\n</code>\n然后有 3 个变量可用：<code>clientid</code>、<code>qos</code> 和 <code>payload</code>。 如果我们将参数设置为：\n<code>\n    {\n        topic = \"t/${clientid}\"\n        qos = \"${qos}\"\n        payload = \"msg: ${payload}\"\n    }\n</code>\n当收到一条消息 payload = `hello`, qos = 1, clientid = `Steve` 时，将重新发布一条新的 MQTT 消息到主题 `t/Steve`\n消息内容为 payload = `msg: hello`, and `qos = 1",
      "label": "重新发布参数"
    },
    "desc_rule_engine": {
      "desc": "配置 EMQX 规则引擎。",
      "label": "配置规则引擎"
    },
    "desc_rules": {
      "desc": "配置规则",
      "label": "配置规则"
    },
    "desc_user_provided_function": {
      "desc": "配置用户函数",
      "label": "配置用户函数"
    },
    "republish_args_mqtt_properties": {
      "desc": "从消息中应该获取哪个变量作为消息的 MQTT 发布属性。\n可以使用像<code>${.payload.content_type}</code>这样的占位符。",
      "label": "MQTT 属性"
    },
    "republish_args_payload": {
      "desc": "要重新发布的消息的有效负载。允许使用带有变量的模板，请参阅“republish_args”的描述。\n默认为 ${payload}。 如果从所选结果中未找到变量 ${payload}，则使用字符串 \"undefined\"。",
      "label": "消息负载"
    },
    "republish_args_qos": {
      "desc": "要重新发布的消息的 qos。允许使用带有变量的模板，请参阅“republish_args”的描述。\n默认为 ${qos}。 如果从规则的选择结果中没有找到变量 ${qos}，则使用 0。",
      "label": "消息 QoS 等级"
    },
    "republish_args_retain": {
      "desc": "要重新发布的消息的“保留”标志。允许使用带有变量的模板，请参阅“republish_args”的描述。\n默认为 ${retain}。 如果从所选结果中未找到变量 ${retain}，则使用 false。",
      "label": "保留消息标志"
    },
    "republish_args_topic": {
      "desc": "重新发布消息的目标主题。\n允许使用带有变量的模板，请参阅“republish_args”的描述。",
      "label": "目标主题"
    },
    "republish_args_user_properties": {
      "desc": "指定使用哪个变量来填充 MQTT 消息的 User-Property 列表。这个变量的值必须是一个 map 类型。\n可以设置成 <code>${pub_props.'User-Property'}</code> 或者\n使用 <code>SELECT *,pub_props.'User-Property' as user_properties</code> 来把源 MQTT 消息\n的 User-Property 列表用于填充。\n也可以使用 <code>map_put</code> 函数来添加新的 User-Property，\n<code>map_put('my-prop-name', 'my-prop-value', user_properties) as user_properties</code>\n注意：MQTT 协议允许一个消息中出现多次同一个 property 名，但是 EMQX 的规则引擎不允许。",
      "label": "用户属性"
    },
    "republish_function": {
      "desc": "将消息重新发布为新的 MQTT 消息",
      "label": "重新发布函数"
    },
    "rule_engine_ignore_sys_message": {
      "desc": "当设置为“true”（默认）时，规则引擎将忽略发布到 $SYS 主题的消息。",
      "label": "忽略系统消息"
    },
    "rule_engine_jq_function_default_timeout": {
      "desc": "规则引擎内建函数 `jq` 默认时间限制",
      "label": "规则引擎 jq 函数时间限制"
    },
    "rule_engine_jq_implementation_module": {
      "desc": "jq 规则引擎功能的实现模块。可用的两个选项是 jq_nif 和 jq_port。jq_nif 使用 Erlang NIF 库访问 jq 库，而 jq_port 使用基于 Erlang Port 的实现。jq_nif 方式（默认选项）是这两个选项中最快的实现，但 jq_port 方式更安全，因为这种情况下 jq 程序不会在 Erlang VM 进程中执行。",
      "label": "JQ 实现模块"
    },
    "rule_engine_rules": {
      "desc": "规则",
      "label": "规则"
    },
    "rules_actions": {
      "desc": "规则的动作列表。\n动作可以是指向 EMQX 数据桥接的引用，也可以是一个指向函数的对象。\n我们支持一些内置函数，如“republish”和“console”，我们还支持用户提供的函数，它的格式为：“{module}:{function}”。\n列表中的动作按顺序执行。这意味着如果其中一个动作执行缓慢，则以下所有动作都不会被执行直到它返回。\n如果其中一个动作崩溃，在它之后的所有动作仍然会被按照原始顺序执行。\n如果运行动作时出现任何错误，则会出现错误消息，并且相应的计数器会增加。",
      "label": "动作列表"
    },
    "rules_description": {
      "desc": "规则的描述",
      "label": "规则描述"
    },
    "rules_enable": {
      "desc": "启用或禁用规则引擎",
      "label": "启用或禁用规则引擎"
    },
    "rules_metadata": {
      "desc": "规则的元数据，不要手动修改",
      "label": "规则的元数据"
    },
    "rules_name": {
      "desc": "规则名字",
      "label": "规则名字"
    },
    "rules_sql": {
      "desc": "用于处理消息的 SQL 。\n示例：<code>SELECT * FROM \"test/topic\" WHERE payload.x = 1</code>",
      "label": "规则 SQL"
    },
    "user_provided_function_args": {
      "desc": "用户提供的参数将作为函数 module:function/3 的第三个参数，\n请检查源文件：<code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> 中的示例函数 <code>console</code> 和<code>republish</code> 。",
      "label": "用户提供函数的参数"
    },
    "user_provided_function_function": {
      "desc": "用户提供的函数。 格式应为：'{module}:{function}'。\n其中 {module} 是 Erlang 回调模块， {function} 是 Erlang 函数。\n要编写自己的函数，请检查源文件：<code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> 中的示例函数 <code>console</code> 和<code>republish</code> 。",
      "label": "用户提供的函数"
    }
  },
  "emqx_s3_schema": {
    "access_key_id": {
      "desc": "The access key ID of the S3 bucket."
    },
    "acl": {
      "desc": "The ACL to use for the uploaded objects."
    },
    "bucket": {
      "desc": "The name of the S3 bucket."
    },
    "host": {
      "desc": "The host of the S3 endpoint."
    },
    "ipv6_probe": {
      "desc": "Whether to probe for IPv6 support."
    },
    "max_part_size": {
      "desc": "The maximum part size for multipart uploads.<br/>\nS3 uploader won't try to upload parts larger than this size."
    },
    "min_part_size": {
      "desc": "The minimum part size for multipart uploads.<br/>\nUploaded data will be accumulated in memory until this size is reached."
    },
    "port": {
      "desc": "The port of the S3 endpoint."
    },
    "secret_access_key": {
      "desc": "The secret access key of the S3 bucket."
    },
    "transport_options": {
      "desc": "Options for the HTTP transport layer used by the S3 client."
    },
    "url_expire_time": {
      "desc": "The time in seconds for which the signed URLs to the S3 objects are valid."
    }
  },
  "emqx_schema": {
    "alarm_actions": {
      "desc": "警报激活时触发的动作。<br/>目前，支持以下操作：<code>log</code> 和 <code>publish</code>.\n<code>log</code> 将告警写入日志 (控制台或者文件).\n<code>publish</code> 将告警作为 MQTT 消息发布到系统主题:\n<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and\n<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>",
      "label": "告警动作"
    },
    "alarm_size_limit": {
      "desc": "要保留为历史记录的已停用报警的最大总数。当超过此限制时，将删除最旧的停用报警，以限制总数。",
      "label": "告警总数限制"
    },
    "alarm_validity_period": {
      "desc": "停用报警的保留时间。报警在停用时不会立即删除，而是在保留时间之后删除。",
      "label": "告警保留时间"
    },
    "base_listener_acceptors": {
      "desc": "监听器接收池的大小。",
      "label": "接收器数量"
    },
    "base_listener_bind": {
      "desc": "监听套接字的 IP 地址和端口。",
      "label": "IP 地址和端口"
    },
    "base_listener_enable_authn": {
      "desc": "配置 <code>true</code> （默认值）启用客户端进行身份认证，通过检查认配置的认认证器链来决定是否允许接入。\n配置 <code>false</code> 时，将不对客户端做任何认证，任何客户端，不论是不是携带用户名等认证信息，都可以接入。\n配置 <code>quick_deny_anonymous</code> 时，行为跟 <code>true</code> 类似，但是会对匿名\n客户直接拒绝，不做使用任何认证器对客户端进行身份检查。",
      "label": "启用身份认证"
    },
    "base_listener_limiter": {
      "desc": "速率限制类型",
      "label": "速率限制类型"
    },
    "base_listener_max_connections": {
      "desc": "监听器允许的最大并发连接数。",
      "label": "最大并发连接数"
    },
    "base_listener_mountpoint": {
      "desc": "发布或订阅时，请在所有主题前面加上 mountpoint 字符串。\n\n将消息传递给订阅者时，将从主题名称中删除带前缀的字符串。挂载点是一种用户可以用来实现不同侦听器之间消息路由隔离的方法。\n\n例如，如果客户机 A 使用 <code>listeners.tcp.\\<name>.mountpoint</code> 设置为'some_tenant'，那么客户端实际上订阅了主题'some_tenant/t'。<br/>\n类似地，如果另一个客户端 B（与客户端 A 连接到同一个侦听器）向主题 't' 发送消息，该消息将路由到所有订阅了'some_租户/t'的客户端，因此客户端 A 将接收主题名为't'的消息<br/>\n\n设置为<code>\"\"</code> 以禁用该功能<br/>\n\nmountpoint 字符串中的变量：\n- <code>${clientid}</code>: clientid\n- <code>${username}</code>: username",
      "label": "mountpoint"
    },
    "base_listener_zone": {
      "desc": "监听器所属的配置组。",
      "label": "配置组"
    },
    "broker": {
      "desc": "Broker 相关配置项。"
    },
    "broker_enable_session_registry": {
      "desc": "是否启用 Session Registry"
    },
    "broker_perf_route_lock_type": {
      "desc": "通配符主题订阅/取消订阅性能调优。\n建议仅当通配符主题较多时才更改此参数。\n\n注：当从 `global` 锁更改或更改为 `gloabal` 锁时，它要求集群中的所有节点在更改之前停止。\n  - `key`：为 mnesia 事务涉及到的每个 key 上锁，建议单节点时使用。\n  - `tab`：为 mnesia 事务涉及到的表上锁，建议在集群中使用。\n  - `global`：所以更新操作都被全局的锁保护，仅建议在超大规模集群中使用。"
    },
    "broker_perf_trie_compaction": {
      "desc": "是否开启主题表压缩存储。\n启用它会显着提高通配符主题订阅率，如果通配符主题具有唯一前缀，例如：'sensor/{{id}}/+/'，其中每个订阅者的 ID 是唯一的。\n如果消息主要发布到具有大量级别的主题，则主题匹配性能（发布时）可能会降低。\n\n注意：这是一个集群范围的配置。 它要求在更改之前停止所有节点。"
    },
    "broker_routing_storage_schema": {
      "desc": "路由存储模式。\n设置为 <code>v1</code> 以保留默认设置。\n<code>v2</code> 在版本 5.2 中引入。它允许通过两个单独的表进行路由，一个用于主题过滤，一个用于常规主题订阅。这个模式会同时提高订阅和路由性能，但会略微增加每个订阅的内存消耗。\n注意：模式 <code>v2</code> 仍然处于实验阶段。\n注意：更改此选项后，需要进行完整的非滚动集群重启才能生效。"
    },
    "broker_session_locking_strategy": {
      "desc": "Session 在集群中的锁策略。\n  - `loca`：仅锁本节点的 Session；\n  - `one`：任选一个其它节点加锁；\n  - `quorum`：选择集群中半数以上的节点加锁；\n  - `all`：选择所有节点加锁。"
    },
    "broker_shared_dispatch_ack_enabled": {
      "desc": "该配置项已废弃。\n启用/禁用 QoS 1 和 QoS 2 消息的共享派发确认。\n该配置最初设计用于避免将消息派发给客户端离线状态下的会话中去。\n但新版本中，已做增强：在一个会话结束时，会话中的消息会重新派发到组内的其他会话中 -- 使这个老配置失去存在的意义。"
    },
    "broker_shared_subscription_strategy": {
      "desc": "共享订阅消息派发策略。\n  - `random`：随机选择一个订阅者派发；\n  - `round_robin`：单个发布者的消息轮流派发给订阅者；\n  - `round_robin_per_group`：所有消息轮流派发给订阅者；\n  - `local`：随机选择当前节点上的订阅者，如果当前节点没有订阅者则在集群范围内随机选择;\n  - `sticky`：持续向初次选中的订阅者派发消息，直至其结束会话;\n  - `hash_clientid`：对发布者客户端 ID 进行 Hash 处理以选择订阅者;\n  - `hash_topic`：对发布主题进行 Hash 处理以选择订阅者。"
    },
    "bytes_rate": {
      "desc": "数据发布速率。<br/> 用于限制连接到该监听器的每个客户端的入站字节速率，一旦达到限制值，受限制的客户端将会减速甚至暂时被挂起。",
      "label": "数据发布速率"
    },
    "ciphers_schema_common": {
      "desc": "此配置保存由逗号分隔的 TLS 密码套件名称，或作为字符串数组。例如\n<code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code>或\n<code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>。\n<br/>\n密码（及其顺序）定义了客户端和服务器通过网络连接加密信息的方式。\n选择一个好的密码套件对于应用程序的数据安全性、机密性和性能至关重要。\n\n名称应为 OpenSSL 字符串格式（而不是 RFC 格式）。\nEMQX 配置文档提供的所有默认值和示例都是 OpenSSL 格式<br/>\n注意：某些密码套件仅与特定的 TLS <code>版本</code>兼容（'tlsv1.1'、'tlsv1.2'或'tlsv1.3'）。\n不兼容的密码套件将被自动删除。\n\n例如，如果只有 <code>versions</code> 仅配置为 <code>tlsv1.3</code>。为其他版本配置密码套件将无效。\n\n<br/>\n注：PSK 的 Ciphers 不支持 tlsv1.3<br/>\n如果打算使用 PSK 密码套件, <code>tlsv1.3</code> 应在<code>ssl.versions</code>中禁用。\n\n<br/>\nPSK 密码套件：\n<code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,\nRSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,\nRSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,\nRSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
      "label": ""
    },
    "ciphers_schema_quic": {
      "desc": "此配置保存由逗号分隔的 TLS 密码套件名称，或作为字符串数组。例如\n<code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code>或\n<code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>。\n<br/>\n密码（及其顺序）定义了客户端和服务器通过网络连接加密信息的方式。\n选择一个好的密码套件对于应用程序的数据安全性、机密性和性能至关重要。\n\n名称应为 OpenSSL 字符串格式（而不是 RFC 格式）。\nEMQX 配置文档提供的所有默认值和示例都是 OpenSSL 格式。<br/>\n注意：某些密码套件仅与特定的 TLS <code>版本</code>兼容（'tlsv1.1'、'tlsv1.2'或'tlsv1.3'）。\n不兼容的密码套件将被自动删除。\n\n例如，如果只有 <code>versions</code> 仅配置为 <code>tlsv1.3</code>。为其他版本配置密码套件将无效。\n\n<br/>\n注：PSK 的 Ciphers 不支持 tlsv1.3。<br/>\n如果打算使用 PSK 密码套件，<code>tlsv1.3</code> 应在 <code>ssl.versions</code> 中禁用。\n\n<br/>\nPSK 密码套件：\n<code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,\nRSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,\nRSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,\nRSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code><br/>\n\n注：QUIC 监听器只支持 tlsv1.3 的 ciphers。",
      "label": ""
    },
    "client_ssl_opts_schema_enable": {
      "desc": "启用 TLS。",
      "label": "启用 TLS"
    },
    "client_ssl_opts_schema_server_name_indication": {
      "desc": "指定要在 TLS 服务器名称指示扩展中使用的主机名。<br/>\n例如，当连接到 \"server.example.net\" 时，接受连接并执行 TLS 握手的真正服务器可能与 TLS 客户端最初连接到的主机不同，\n例如，当连接到 IP 地址时，或者当主机具有多个可解析的 DNS 记录时<br/>\n如果未指定，它将默认为使用的主机名字符串\n建立连接，除非使用 IP 地址<br/>\n然后，主机名也用于对等机的主机名验证证书<br/>\n特殊值 <code>disable</code> 阻止发送服务器名称指示扩展，并禁用主机名验证检查。",
      "label": "服务器名称指示"
    },
    "common_ssl_opts_schema_cacertfile": {
      "desc": "受信任的 PEM 格式 CA  证书捆绑文件<br/>\n此文件中的证书用于验证 TLS 对等方的证书。\n如果要信任新 CA，请将新证书附加到文件中。\n无需重启 EMQX 即可加载更新的文件，因为系统会定期检查文件是否已更新（并重新加载）<br/>\n注意：从文件中失效（删除）证书不会影响已建立的连接。",
      "label": "CA 证书文件"
    },
    "common_ssl_opts_schema_cacerts": {
      "desc": "启用时，使用系统信任的 CA 证书来建立 TLS 连接。",
      "label": "使用系统 CA 证书"
    },
    "common_ssl_opts_schema_certfile": {
      "desc": "PEM 格式证书链文件<br/>\n此文件中的证书应与证书颁发链的顺序相反。也就是说，主机的证书应该放在文件的开头，\n然后是直接颁发者 CA 证书，依此类推，一直到根 CA 证书。\n根 CA 证书是可选的，如果想要添加，应加到文件到最末端。",
      "label": "证书文件"
    },
    "common_ssl_opts_schema_depth": {
      "desc": "在有效的证书路径中，可以跟随对等证书的非自颁发中间证书的最大数量。\n因此，如果深度为 0，则对等方必须由受信任的根 CA 直接签名；<br/>\n如果是 1，路径可以是 PEER、中间 CA、ROOT-CA；<br/>\n如果是 2，则路径可以是 PEER、中间 CA1、中间 CA2、ROOT-CA。",
      "label": "CA 证书深度"
    },
    "common_ssl_opts_schema_hibernate_after": {
      "desc": "在闲置一定时间后休眠 SSL 进程，减少其内存占用。",
      "label": "闲置多久后休眠"
    },
    "common_ssl_opts_schema_keyfile": {
      "desc": "PEM 格式的私钥文件。",
      "label": "私钥文件"
    },
    "common_ssl_opts_schema_log_level": {
      "desc": "SSL 握手的日志级别。默认值是 'notice'，可以设置为 'debug' 用来调查 SSL 握手的问题。",
      "label": "SSL 日志级别"
    },
    "common_ssl_opts_schema_password": {
      "desc": "包含用户密码的字符串。仅在私钥文件受密码保护时使用。",
      "label": "秘钥文件密码"
    },
    "common_ssl_opts_schema_reuse_sessions": {
      "desc": "启用 TLS 会话重用。",
      "label": "TLS 会话重用"
    },
    "common_ssl_opts_schema_secure_renegotiate": {
      "desc": "SSL 参数重新协商是一种允许客户端和服务器动态重新协商 SSL 连接参数的功能。\nRFC 5746 定义了一种更安全的方法。通过启用安全的重新协商，您就失去了对不安全的重新协商的支持，从而容易受到 MitM 攻击。",
      "label": "SSL 重新协商"
    },
    "common_ssl_opts_schema_user_lookup_fun": {
      "desc": "用于查找预共享密钥（PSK）标识的 EMQX 内部回调。",
      "label": "SSL PSK 用户回调"
    },
    "common_ssl_opts_schema_verify": {
      "desc": "启用或禁用对等验证。",
      "label": "对等验证"
    },
    "common_ssl_opts_schema_versions": {
      "desc": "支持所有 TLS/DTLS 版本<br/>\n注：PSK 的 Ciphers 无法在 <code>tlsv1.3</code> 中使用，如果打算使用 PSK 密码套件，请确保这里配置为 <code>[\"tlsv1.2\",\"tlsv1.1\"]</code>。",
      "label": "SSL 版本"
    },
    "conn_congestion_enable_alarm": {
      "desc": "启用或者禁用连接阻塞告警功能。",
      "label": "启用/禁用阻塞告警"
    },
    "conn_congestion_min_alarm_sustain_duration": {
      "desc": "清除警报前的最短时间。<br/>只有当队列中没有挂起的数据，并且连接至少被堵塞了 <code>min_alarm_sustain_duration</code> 毫秒时，<br/>报警才会被清除。这是为了避免太频繁地清除和再次发出警报。",
      "label": "告警维持时间"
    },
    "crl_cache_capacity": {
      "desc": "缓存中可容纳的 CRL URL 的最大数量。 如果缓存的大小已满，并且必须获取一个新的 URL，那么它将驱逐缓存中插入的最老的 URL。",
      "label": "CRL 缓存大小"
    },
    "crl_cache_refresh_http_timeout": {
      "desc": "获取 CRLs 时 HTTP 请求的超时。 该配置对所有启用 CRL 检查的监听器监听器有效。",
      "label": "CRL 缓存刷新 HTTP 超时"
    },
    "crl_cache_refresh_interval": {
      "desc": "从服务器刷新 CRL 的周期。 该配置对所有 URL 和监听器有效。",
      "label": "CRL 缓存刷新间隔"
    },
    "description": {
      "desc": "描述性文本。",
      "label": "描述"
    },
    "fields_authorization_deny_action": {
      "desc": "授权检查拒绝操作时的操作。",
      "label": "授权检查拒绝操作时的操作"
    },
    "fields_authorization_no_match": {
      "desc": "如果用户或客户端不匹配 ACL 规则，或者从可配置授权源(比如内置数据库、HTTP API 或 PostgreSQL 等。)内未找\n到此类用户或客户端时，模式的认访问控制操作。\n在“授权”中查找更多详细信息。",
      "label": "未匹时的默认授权动作"
    },
    "fields_cache_enable": {
      "desc": "启用或禁用授权缓存。",
      "label": "启用或禁用授权缓存"
    },
    "fields_cache_max_size": {
      "desc": "缓存项的最大数量。",
      "label": "缓存项的最大数量"
    },
    "fields_cache_ttl": {
      "desc": "缓存数据的生存时间。",
      "label": "缓存数据的生存时间。"
    },
    "fields_deflate_opts_client_context_takeover": {
      "desc": "接管意味着在客户端消息之间保留压缩状态。",
      "label": "客户端上下文接管"
    },
    "fields_deflate_opts_client_max_window_bits": {
      "desc": "指定客户端压缩上下文的大小。",
      "label": "压缩窗口大小"
    },
    "fields_deflate_opts_level": {
      "desc": "压缩级别",
      "label": "压缩级别"
    },
    "fields_deflate_opts_mem_level": {
      "desc": "指定压缩状态的大小<br/>\n较低的值会减少每个连接的内存使用。",
      "label": "压缩状态大小"
    },
    "fields_deflate_opts_server_context_takeover": {
      "desc": "接管意味着在服务器消息之间保留压缩状态。",
      "label": "服务上下文接管"
    },
    "fields_deflate_opts_server_max_window_bits": {
      "desc": "指定服务器压缩上下文的大小。",
      "label": "服务器压缩窗口大小"
    },
    "fields_deflate_opts_strategy": {
      "desc": "指定压缩策略。",
      "label": "指定压缩策略"
    },
    "fields_listener_enabled": {
      "desc": "启停监听器。",
      "label": "启停监听器"
    },
    "fields_listeners_quic": {
      "desc": "QUIC 监听器。",
      "label": "QUIC 监听器"
    },
    "fields_listeners_ssl": {
      "desc": "SSL 监听器。",
      "label": "SSL 监听器"
    },
    "fields_listeners_tcp": {
      "desc": "TCP 监听器。",
      "label": "TCP 监听器"
    },
    "fields_listeners_ws": {
      "desc": "HTTP websocket 监听器。",
      "label": "HTTP websocket 监听器"
    },
    "fields_listeners_wss": {
      "desc": "HTTPS websocket 监听器。",
      "label": "HTTPS websocket 监听器"
    },
    "fields_mqtt_quic_listener_certfile": {
      "desc": "证书文件。在 5.1 中会被废弃，使用 .ssl_options.certfile 代替。",
      "label": "证书文件"
    },
    "fields_mqtt_quic_listener_conn_flow_control_window": {
      "desc": "连接的流控窗口。默认：16777216",
      "label": "流控窗口"
    },
    "fields_mqtt_quic_listener_datagram_receive_enabled": {
      "desc": "宣传对 QUIC Datagram 扩展的支持。为将来保留。默认为 0（FALSE）",
      "label": "启用 Datagram 接收"
    },
    "fields_mqtt_quic_listener_disconnect_timeout_ms": {
      "desc": "在判定路径无效和断开连接之前，要等待多长时间的 ACK。默认：16000",
      "label": "断开连接超时 毫秒"
    },
    "fields_mqtt_quic_listener_handshake_idle_timeout": {
      "desc": "一个握手在被丢弃之前可以空闲多长时间。",
      "label": "握手空闲超时时间"
    },
    "fields_mqtt_quic_listener_handshake_idle_timeout_ms": {
      "desc": "一个握手在被丢弃之前可以空闲多长时间",
      "label": "握手空闲超时 毫秒"
    },
    "fields_mqtt_quic_listener_idle_timeout": {
      "desc": "一个连接在被关闭之前可以空闲多长时间。0 表示禁用。",
      "label": "空闲超时时间"
    },
    "fields_mqtt_quic_listener_idle_timeout_ms": {
      "desc": "一个连接在被优雅地关闭之前可以空闲多长时间。0 表示禁用超时",
      "label": "空闲超时 毫秒"
    },
    "fields_mqtt_quic_listener_initial_rtt_ms": {
      "desc": "初始 RTT 估计",
      "label": "Initial RTT 毫秒"
    },
    "fields_mqtt_quic_listener_initial_window_packets": {
      "desc": "一个连接的初始拥堵窗口的大小（以包为单位）。默认值：10",
      "label": "初始窗口数据包"
    },
    "fields_mqtt_quic_listener_keep_alive_interval": {
      "desc": "发送 PING 帧的频率，以保活连接. 设为 0 表示禁用。",
      "label": "Keep Alive 间隔"
    },
    "fields_mqtt_quic_listener_keep_alive_interval_ms": {
      "desc": "多长时间发送一次 PING 帧以保活连接。",
      "label": "Keep Alive 间隔毫秒"
    },
    "fields_mqtt_quic_listener_keyfile": {
      "desc": "私钥文件。在 5.1 中会被废弃，使用 .ssl_options.keyfile 代替。",
      "label": "私钥文件"
    },
    "fields_mqtt_quic_listener_load_balancing_mode": {
      "desc": "0: 禁用, 1: SERVER_ID_IP, 2: SERVER_ID_FIXED. 默认: 0",
      "label": "负载平衡模式"
    },
    "fields_mqtt_quic_listener_max_ack_delay_ms": {
      "desc": "在收到数据后要等待多长时间才能发送一个 ACK。默认值：25",
      "label": "最大应答延迟 毫秒"
    },
    "fields_mqtt_quic_listener_max_binding_stateless_operations": {
      "desc": "在任何时候可以在一个绑定上排队的无状态操作的最大数量。默认值：100",
      "label": "最大绑定无状态操作"
    },
    "fields_mqtt_quic_listener_max_bytes_per_key": {
      "desc": "在启动密钥更新之前，用单个 1-RTT 加密密钥加密的最大字节数。默认值：274877906944",
      "label": "每个密钥的最大字节数"
    },
    "fields_mqtt_quic_listener_max_operations_per_drain": {
      "desc": "每个连接操作的最大耗费操作数。默认：16",
      "label": "每次操作最大操作数"
    },
    "fields_mqtt_quic_listener_max_stateless_operations": {
      "desc": "无状态操作的最大数量，在任何时候都可以在一个工作者上排队。默认值：16",
      "label": "最大无状态操作数"
    },
    "fields_mqtt_quic_listener_maximum_mtu": {
      "desc": "一个连接所支持的最大 MTU。这将是最大的探测值。默认值：1500",
      "label": "最大 MTU"
    },
    "fields_mqtt_quic_listener_migration_enabled": {
      "desc": "开启客户端地址迁移功能。需要一个支持的负载平衡器，或者没有负载平衡器。默认值：1（已启用）",
      "label": "启用地址迁移"
    },
    "fields_mqtt_quic_listener_minimum_mtu": {
      "desc": "一个连接所支持的最小 MTU。这将被作为起始 MTU 使用。默认值：1248",
      "label": "最小 MTU"
    },
    "fields_mqtt_quic_listener_mtu_discovery_missing_probe_count": {
      "desc": "在任何时候都可以在一个绑定上排队的无状态操作的最大数量。默认值：3",
      "label": "MTU 发现丢失的探针数量"
    },
    "fields_mqtt_quic_listener_mtu_discovery_search_complete_timeout_us": {
      "desc": "如果没有达到 max ，在重新尝试 MTU 探测之前要等待的时间，单位是微秒。默认值：600000000",
      "label": "MTU 发现搜索完成超时（微秒）"
    },
    "fields_mqtt_quic_listener_pacing_enabled": {
      "desc": "有节奏的发送，以避免路径上的缓冲区过度填充。默认值：1（已启用）",
      "label": "启用节奏发送"
    },
    "fields_mqtt_quic_listener_peer_bidi_stream_count": {
      "desc": "允许对端打开的双向流的数量",
      "label": "对端双向流的数量"
    },
    "fields_mqtt_quic_listener_peer_unidi_stream_count": {
      "desc": "允许对端打开的单向流的数量",
      "label": "对端单向流的数量"
    },
    "fields_mqtt_quic_listener_retry_memory_limit": {
      "desc": "在使用无状态重试之前，可用于握手连接的可用内存的百分比。计算为`N/65535`。默认值：65",
      "label": "重试内存限制"
    },
    "fields_mqtt_quic_listener_send_buffering_enabled": {
      "desc": "缓冲发送数据，而不是保留应用缓冲区，直到发送数据被确认。默认值：1（启用）",
      "label": "启用发送缓冲功能"
    },
    "fields_mqtt_quic_listener_send_idle_timeout_ms": {
      "desc": "在闲置一定时间后重置拥堵控制。默认值：1000",
      "label": "发送空闲超时毫秒"
    },
    "fields_mqtt_quic_listener_server_resumption_level": {
      "desc": "连接恢复 和/或 0-RTT 服务器支持。默认值：0（无恢复功能）",
      "label": "服务端连接恢复支持"
    },
    "fields_mqtt_quic_listener_ssl_options": {
      "desc": "QUIC 传输层的 TLS 选项",
      "label": "TLS 选项"
    },
    "fields_mqtt_quic_listener_stateless_operation_expiration_ms": {
      "desc": "同一个对端的操作之间的时间限制，单位是毫秒。 默认：100",
      "label": "无状态操作过期 毫秒"
    },
    "fields_mqtt_quic_listener_stream_recv_buffer_default": {
      "desc": "流的初始缓冲区大小。默认：4096",
      "label": "流媒体接收缓冲区默认值"
    },
    "fields_mqtt_quic_listener_stream_recv_window_default": {
      "desc": "初始流接收窗口大小。 默认值：32678",
      "label": "流接收窗口默认"
    },
    "fields_mqtt_quic_listener_tls_server_max_send_buffer": {
      "desc": "缓冲多少 TLS 数据。 默认值：8192",
      "label": "TLS 服务器最大发送缓冲区"
    },
    "fields_rate_limit_conn_bytes_in": {
      "desc": "限制 MQTT 连接接收数据包的速率。 速率以每秒的数据包字节数计算。",
      "label": "数据包速率"
    },
    "fields_rate_limit_conn_messages_in": {
      "desc": "外部 MQTT 连接的消息限制。",
      "label": "外部 MQTT 连接的消息限制"
    },
    "fields_rate_limit_max_conn_rate": {
      "desc": "每秒最大连接数。",
      "label": "每秒最大连接数"
    },
    "fields_tcp_opts_active_n": {
      "desc": "为此套接字指定{active，N}选项<br/>\nSee: https://erlang.org/doc/man/inet.html#setopts-2",
      "label": "active_n"
    },
    "fields_tcp_opts_backlog": {
      "desc": "TCP backlog 定义了挂起连接队列可以增长到的最大长度。",
      "label": "TCP 连接队列长度"
    },
    "fields_tcp_opts_buffer": {
      "desc": "驱动程序使用的用户空间缓冲区的大小。",
      "label": "TCP 用户态缓冲区"
    },
    "fields_tcp_opts_high_watermark": {
      "desc": "当 VM 套接字实现内部排队的数据量达到此限制时，套接字将设置为忙碌状态。",
      "label": "TCP 高水位线"
    },
    "fields_tcp_opts_keepalive": {
      "desc": "为 MQTT 连接在 TCP 或 SSL 上启用 TCP 保活。\n值是以逗号分隔的三个数字，格式为 'Idle,Interval,Probes'\n - Idle: 在服务器开始发送保活探测之前，连接需要处于空闲状态的秒数（Linux 默认为 7200）。\n - Interval: TCP 保活探测间隔的秒数（Linux 默认值为 75）。\n - Probes: 在放弃并终止连接之前，从另一端未获得响应时要发送的 TCP 保活探测的最大数量（Linux 默认值为 9 次）。\n例如 \"240,30,5\" 表示：在连接空闲 240 秒后发送 TCP 保活探测，每隔 30 秒发送一次，直到收到响应，如果连续丢失 5 个响应，连接应该被关闭。\n默认值为 'none'",
      "label": "TCP keepalive 选项"
    },
    "fields_tcp_opts_nodelay": {
      "desc": "连接的 TCP_NODELAY 标识",
      "label": "TCP_NODELAY"
    },
    "fields_tcp_opts_recbuf": {
      "desc": "连接的 TCP 接收缓冲区（OS 内核）。",
      "label": "TCP 接收缓冲区"
    },
    "fields_tcp_opts_reuseaddr": {
      "desc": "连接的 SO_REUSEADDR 标识。",
      "label": "SO_REUSEADDR"
    },
    "fields_tcp_opts_send_timeout": {
      "desc": "连接的 TCP 发送超时。",
      "label": "TCP 发送超时"
    },
    "fields_tcp_opts_send_timeout_close": {
      "desc": "如果发送超时，则关闭连接。",
      "label": "TCP 发送超时关闭连接"
    },
    "fields_tcp_opts_sndbuf": {
      "desc": "连接的 TCP 发送缓冲区（OS 内核）。",
      "label": "TCP 发送缓冲区"
    },
    "fields_trace_payload_encode": {
      "desc": "确定跟踪文件中有效负载格式的格式。<br/>\n`text`：基于文本的协议或纯文本协议。\n建议在有效负载为 JSON 编码时使用<br/>\n`hex`：二进制十六进制编码。当有效负载是自定义二进制协议时，建议使用此选项<br/>\n`hidden`：有效负载被模糊化为 `******`",
      "label": "有效负载编码"
    },
    "fields_ws_opts_allow_origin_absence": {
      "desc": "如果设置为 <code>false</code> 并且 <code>check_origin_enable</code> 为 <code>true</code>，服务器将拒绝没有 <code>origin</code> HTTP 头的请求。",
      "label": "允许 origin 缺失"
    },
    "fields_ws_opts_check_origin_enable": {
      "desc": "如果<code>true</code>，<code>origin</code>HTTP 头将根据<code>check_origins</code>参数中配置的允许来源列表进行验证。",
      "label": "检查 origin"
    },
    "fields_ws_opts_check_origins": {
      "desc": "允许的 origins 列表",
      "label": "允许的 origins"
    },
    "fields_ws_opts_compress": {
      "desc": "如果 <code>true</code>，则使用 <code>zlib</code> 压缩 WebSocket 消息<br/>\n<code>deflate_opts</code> 下的配置项属于压缩相关参数配置。",
      "label": "Ws 压缩"
    },
    "fields_ws_opts_fail_if_no_subprotocol": {
      "desc": "如果<code>true</code>，当客户端未携带<code>Sec WebSocket Protocol</code>字段时，服务器将返回一个错误。\n<br/>注意：微信小程序需要禁用此验证。",
      "label": "无 subprotocol 则失败"
    },
    "fields_ws_opts_idle_timeout": {
      "desc": "关闭在此间隔内未发送 MQTT CONNECT 消息的客户端的传输层连接。",
      "label": "WS 空闲时间"
    },
    "fields_ws_opts_max_frame_size": {
      "desc": "单个 MQTT 数据包的最大长度。",
      "label": "最大数据包长度"
    },
    "fields_ws_opts_mqtt_path": {
      "desc": "WebSocket 的 MQTT 协议路径。因此，EMQX Broker 的 WebSocket 地址为：\n<code>ws://{ip}:{port}/mqtt</code>",
      "label": "WS MQTT 路径"
    },
    "fields_ws_opts_mqtt_piggyback": {
      "desc": "WebSocket 消息是否允许包含多个 MQTT 数据包。",
      "label": "MQTT Piggyback"
    },
    "fields_ws_opts_proxy_address_header": {
      "desc": "HTTP 头，用于传递有关客户端 IP 地址的信息。\n当 EMQX 集群部署在负载平衡器后面时，这一点非常重要。",
      "label": "客户端地址头"
    },
    "fields_ws_opts_proxy_port_header": {
      "desc": "HTTP 头，用于传递有关客户端端口的信息。当 EMQX 集群部署在负载平衡器后面时，这一点非常重要。",
      "label": "客户端端口头"
    },
    "fields_ws_opts_supported_subprotocols": {
      "desc": "逗号分隔的 subprotocols 支持列表。",
      "label": "Subprotocols 支持列表"
    },
    "flapping_detect_ban_time": {
      "desc": "抖动的客户端将会被禁止登录多长时间。",
      "label": "禁止登录时长"
    },
    "flapping_detect_enable": {
      "desc": "启用抖动检测功能。",
      "label": "启用抖动检测"
    },
    "flapping_detect_max_count": {
      "desc": "MQTT 客户端在“窗口”时间内允许的最大断开次数",
      "label": "最大断开次数"
    },
    "flapping_detect_window_time": {
      "desc": "抖动检测的时间窗口。",
      "label": "时间窗口"
    },
    "force_gc_bytes": {
      "desc": "在进程处理过多少个字节之后，对此进程执行垃圾回收。",
      "label": "垃圾回收字节数"
    },
    "force_gc_count": {
      "desc": "在进程收到多少消息之后，对此进程执行垃圾回收。",
      "label": "垃圾回收消息数"
    },
    "force_gc_enable": {
      "desc": "启用强制垃圾回收。",
      "label": "启用强制垃圾回收"
    },
    "force_shutdown_enable": {
      "desc": "启用 `force_shutdown` 功能。",
      "label": "启用 `force_shutdown` 功能"
    },
    "force_shutdown_max_heap_size": {
      "desc": "Heap 的总大小。",
      "label": "Heap 的总大小"
    },
    "force_shutdown_max_mailbox_size": {
      "desc": "每个在线客户端在 EMQX 服务器中都是独立的一个进程。该配置可以设为单个进程的邮箱消息队列设置最大长度，当超过该上限时，客户端会被强制下线。",
      "label": "进程邮箱消息数上限"
    },
    "global_authentication": {
      "desc": "全局 MQTT 监听器的默认认证配置。 为每个监听器配置认证参考监听器器配置中的<code>authentication</code> 配置。\n\n该配置可以被配置为：\n<ul>\n  <li><code>[]</code>: 默认值，允许所有的登录请求\n  <li>配置为单认证器，例如 <code>{enable:true,backend:\"built_in_database\",mechanism=\"password_based\"}</code></li>\n  <li>配置为认证器数组</li>\n</ul>\n\n当配置为认证链后，登录凭证会按照配置的顺序进行检查，直到做出<code>allow</code> 或 <code>deny</code>的结果。\n\n如果在所有的认证器都执行完后，还是没有结果，登录将被拒绝。"
    },
    "listener_authentication": {
      "desc": "监听器认证重载。\n认证配置可以是单个认证器实例，也可以是一个认证器数组组成的认证链。\n执行登录验证时（用户名、客户端 ID 等），将按配置的顺序执行。",
      "label": "每个监听器的认证覆盖"
    },
    "mqtt": {
      "desc": "全局的 MQTT 配置项。\nmqtt 下所有的配置作为全局的默认值存在，它可以被 <code>zone</code> 中的配置覆盖"
    },
    "mqtt_await_rel_timeout": {
      "desc": "客户端发布 QoS 2 消息时，服务器等待 `PUBREL` 的最长时延。超过该时长后服务器会放弃等待，该 PACKET ID 会被释放，从而允许后续新的 PUBLISH 消息使用。如果超时后收到 PUBREL，服务器将会产生一条告警日志。注意，向订阅客户端转发消息的动作发生在进入等待之前。",
      "label": "PUBREL 最大等待时间"
    },
    "mqtt_exclusive_subscription": {
      "desc": "是否启用对 MQTT 排它订阅的支持。",
      "label": "排它订阅"
    },
    "mqtt_idle_timeout": {
      "desc": "设置连接被断开或进入休眠状态前的等待时间，空闲超时后，\n  - 如暂未收到客户端的 CONNECT 报文，连接将断开；\n  - 如已收到客户端的 CONNECT 报文，连接将进入休眠模式以节省系统资源。\n\n注意：请合理设置该参数值，如等待时间设置过长，可能造成系统资源的浪费。",
      "label": "空闲超时"
    },
    "mqtt_ignore_loop_deliver": {
      "desc": "设置由 MQTT v3.1.1/v3.1.0 客户端发布的消息是否将转发给其本身；类似 MQTT 5.0 协议中的 <code>No Local</code> 选项。",
      "label": "忽略循环投递"
    },
    "mqtt_keepalive_multiplier": {
      "desc": "EMQX 判定客户端 Keep Alive 超时使用的 Keep Alive 倍数。计算公式为：Keep Alive 超时 = Keep Alive 间隔 × Keep Alive 倍数。 默认值 1.5 遵循 MQTT 5.0 规范。此倍数可调整，为系统管理员提供根据特定需求进行定制的灵活性。例如，如果客户端的 10 秒保持连接间隔的 PINGREQ 因为额外的 10 秒延迟，将倍数更改为 2 可以让 EMQX 容忍此延迟。",
      "label": "Keep Alive 倍数"
    },
    "mqtt_listener_access_rules": {
      "desc": "此监听器的访问控制规则。",
      "label": "访问控制规则"
    },
    "mqtt_listener_proxy_protocol": {
      "desc": "如果 EMQX 集群部署在 HAProxy 或 Nginx 之后，请启用代理协议 V1/2 <br/>\n详情见: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
      "label": "Proxy protocol"
    },
    "mqtt_listener_proxy_protocol_timeout": {
      "desc": "代理协议超时。如果在超时时间内未收到代理协议数据包，EMQX 将关闭 TCP 连接。",
      "label": "Proxy protocol 超时时间"
    },
    "mqtt_max_awaiting_rel": {
      "desc": "每个发布者的会话中，都存在一个队列来处理客户端发送的 QoS 2 消息。该队列会存储 QoS 2 消息的报文 ID 直到收到客户端的 PUBREL 或超时，达到队列长度的限制后，新的 QoS 2 消息发布会被拒绝，并返回 `147(0x93)` 错误。",
      "label": "PUBREL 等待队列长度"
    },
    "mqtt_max_clientid_len": {
      "desc": "允许的最大 MQTT Client ID 长度。",
      "label": "最大 Client ID 长度"
    },
    "mqtt_max_inflight": {
      "desc": "允许在完成应答前同时投递的 QoS 1 和 QoS 2 消息的最大数量。",
      "label": "最大飞行窗口"
    },
    "mqtt_max_mqueue_len": {
      "desc": "消息队列最大长度。持久客户端断开连接或飞行窗口已满时排队的消息长度。",
      "label": "最大消息队列长度"
    },
    "mqtt_max_packet_size": {
      "desc": "允许的最大 MQTT 报文大小。",
      "label": "最大报文大小"
    },
    "mqtt_max_qos_allowed": {
      "desc": "允许的最大 QoS 等级。",
      "label": "最大 QoS"
    },
    "mqtt_max_subscriptions": {
      "desc": "允许每个客户端建立的最大订阅数量。",
      "label": "最大订阅数量"
    },
    "mqtt_max_topic_alias": {
      "desc": "允许的最大主题别名数，0 表示不支持主题别名。",
      "label": "最大主题别名"
    },
    "mqtt_max_topic_levels": {
      "desc": "允许的最大主题层级。",
      "label": "最大主题层级"
    },
    "mqtt_mqueue_default_priority": {
      "desc": "默认的主题优先级，不在 <code>主题优先级</code>（<code>mqueue_priorities</code>） 中的主题将会使用该优先级。",
      "label": "默认主题优先级"
    },
    "mqtt_mqueue_priorities": {
      "desc": "主题优先级。取值范围 [1-255]\n默认优先级表为空，即所有的主题优先级相同。\n\n注：优先主题名称中不支持使用逗号和等号。\n注：不在此列表中的主题，被视为最高/最低优先级，这取决于<code>mqtt.mqueue_default_priority</code> 的配置。\n\n示例：\n配置 <code>\"topic/1\" > \"topic/2\"</code>:\n<code>mqueue_priorities: {\"topic/1\": 10, \"topic/2\": 8}</code>",
      "label": "主题优先级"
    },
    "mqtt_mqueue_store_qos0": {
      "desc": "指定在连接断开但会话保持期间，是否需要在消息队列中存储 QoS 0 消息。",
      "label": "存储 QoS 0 消息"
    },
    "mqtt_peer_cert_as_clientid": {
      "desc": "使用对端证书中的 CN、DN 字段或整个证书内容来作为客户端 ID。仅适用于 TLS 连接；\n目前支持：\n- <code>cn</code>: 取证书的 CN 字段\n- <code>dn</code>: 取证书的 DN 字段\n- <code>crt</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书的内容\n- <code>pem</code>: 将 <code>DER</code> 证书内容转换为 <code>PEM</code> 格式作为客户端 ID\n- <code>md5</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书内容的 MD5 值",
      "label": "对端证书作为客户端 ID"
    },
    "mqtt_peer_cert_as_username": {
      "desc": "使用对端证书中的 CN、DN 字段或整个证书内容来作为用户名；仅适用于 TLS 连接。\n目前支持：\n- <code>cn</code>: 取证书的 CN 字段\n- <code>dn</code>: 取证书的 DN 字段\n- <code>crt</code>: 取 <code>DER</code> 或 <code>PEM</code> 的证书内容\n- <code>pem</code>: 将 <code>DER</code> 证书转换为 <code>PEM</code> 格式作为用户名\n- <code>md5</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书内容的 MD5 值",
      "label": "对端证书作为用户名"
    },
    "mqtt_response_information": {
      "desc": "UTF-8 字符串，用于指定返回给客户端的响应主题，如 <code>reqrsp/</code>，此时请求和应答客户端都需要使用 <code>reqrsp/</code> 前缀的主题来完成通讯。\n如希望禁用此功能，请在下方的文字框中输入<code>\"\"</code>；仅适用于 MQTT 5.0 客户端。",
      "label": "响应信息"
    },
    "mqtt_retain_available": {
      "desc": "是否启用对 MQTT 保留消息的支持。",
      "label": "保留消息可用"
    },
    "mqtt_retry_interval": {
      "desc": "QoS 1/2 消息的重新投递间隔。",
      "label": "重试间隔"
    },
    "mqtt_server_keepalive": {
      "desc": "EMQX 要求的保活时间，如设为 disabled，则将使用客户端指定的保持连接时间；仅适用于 MQTT 5.0 客户端。",
      "label": "服务端保活时间"
    },
    "mqtt_session_expiry_interval": {
      "desc": "指定会话将在连接断开后多久过期，仅适用于非 MQTT 5.0 的连接。",
      "label": "会话过期间隔"
    },
    "mqtt_shared_subscription": {
      "desc": "是否启用对 MQTT 共享订阅的支持。",
      "label": "共享订阅可用"
    },
    "mqtt_strict_mode": {
      "desc": "是否以严格模式解析 MQTT 消息。\n严格模式下，如客户端 ID、主题名称等中包含无效 utf8 字符串，连接将被断开。",
      "label": "严格模式"
    },
    "mqtt_upgrade_qos": {
      "desc": "投递消息时，是否根据订阅主题时的 QoS 等级来强制提升派发的消息的 QoS 等级。",
      "label": "升级 QoS"
    },
    "mqtt_use_username_as_clientid": {
      "desc": "是否使用用户名作为客户端 ID。\n此设置的作用时间晚于 <code>对端证书作为用户名</code> 和 <code>对端证书作为客户端 ID</code>。",
      "label": "用户名作为客户端 ID"
    },
    "mqtt_wildcard_subscription": {
      "desc": "是否启用对 MQTT 通配符订阅的支持。",
      "label": "通配符订阅可用"
    },
    "overload_protection_backoff_delay": {
      "desc": "高负载时，一些不重要的任务可能会延迟执行，在这里设置允许延迟的时间。",
      "label": "延迟时间"
    },
    "overload_protection_backoff_gc": {
      "desc": "高负载时，跳过强制 GC。",
      "label": "跳过 GC"
    },
    "overload_protection_backoff_hibernation": {
      "desc": "高负载时，跳过进程休眠。",
      "label": "跳过休眠"
    },
    "overload_protection_backoff_new_conn": {
      "desc": "高负载时，拒绝新进来的客户端连接。",
      "label": "关闭新连接"
    },
    "overload_protection_enable": {
      "desc": "是否对系统过载做出反应。",
      "label": "是否对系统过载做出反应"
    },
    "persistent_session_builtin_messages_table": {
      "desc": "用于内建消息表的性能调优参数。",
      "label": "持久化消息"
    },
    "persistent_session_builtin_sess_msg_table": {
      "desc": "优化内置的会话消息表的配置。",
      "label": "用于内建会话管理表的性能调优参数"
    },
    "persistent_session_builtin_session_table": {
      "desc": "用于内建会话表的性能调优参数。",
      "label": "持久会话"
    },
    "persistent_session_store_backend": {
      "desc": "用于存储持久性会话和信息的数据库管理后端\n- `builtin`: 使用内置的数据库（mria）",
      "label": "后端类型"
    },
    "persistent_session_store_enabled": {
      "desc": "使用数据库存储有关持久会话的信息。\n这使得在节点停止时，可以将客户端连接迁移到另一个群集节点。",
      "label": "启用持久会话保存"
    },
    "persistent_session_store_max_retain_undelivered": {
      "desc": "如果重新启动时处理上一个会话的节点已停止，则未传递到持久会话的消息在垃圾收集之前会被存储。",
      "label": "未投递的消息保留条数"
    },
    "persistent_session_store_message_gc_interval": {
      "desc": "将未送达的消息垃圾收集到持久会话的开始间隔。\n这会影响检查 \"max_retain_undelivered\"（最大保留未送达）的删除频率。",
      "label": "消息清理间隔"
    },
    "persistent_session_store_session_message_gc_interval": {
      "desc": "持久会话消息的临时数据垃圾收集的开始间隔。\n这不会影响持久会话消息的生命周期长度。",
      "label": "会话消息清理间隔"
    },
    "persistent_store_on_disc": {
      "desc": "将持久会话数据保存在磁盘上。如果为 false 则存储在内存中。\n如开启， 持久会话数据可在集群重启后恢复。\n如关闭， 数据仅存储在内存中， 则在整个集群停止后丢失。",
      "label": "持久化在磁盘上"
    },
    "persistent_store_ram_cache": {
      "desc": "在内存中保持一份数据的副本，以便更快地访问。",
      "label": "内存缓存"
    },
    "server_ssl_opts_schema_client_renegotiation": {
      "desc": "在支持客户机发起的重新协商的协议中，这种操作的资源成本对于服务器来说高于客户机。\n这可能会成为拒绝服务攻击的载体。\nSSL 应用程序已经采取措施来反击此类尝试，但通过将此选项设置为 false，可以严格禁用客户端发起的重新协商。\n默认值为 true。请注意，由于基础密码套件可以加密的消息数量有限，禁用重新协商可能会导致长期连接变得不可用。",
      "label": "SSL 客户端冲协商"
    },
    "server_ssl_opts_schema_dhfile": {
      "desc": "如果协商使用 Diffie-Hellman 密钥交换的密码套件，则服务器将使用包含 PEM 编码的 Diffie-Hellman 参数的文件的路径。如果未指定，则使用默认参数。<br/>\n注意：TLS 1.3 不支持<code>dhfile</code>选项。",
      "label": "SSL dhfile"
    },
    "server_ssl_opts_schema_enable_crl_check": {
      "desc": "是否为该监听器启用 CRL 检查。",
      "label": "启用 CRL 检查"
    },
    "server_ssl_opts_schema_enable_ocsp_stapling": {
      "desc": "是否为监听器启用 OCSP Stapling 功能。 如果设置为 true，需要定义 OCSP Responder 的 URL 和证书签发者的 PEM 文件路径。",
      "label": "启用 OCSP Stapling"
    },
    "server_ssl_opts_schema_fail_if_no_peer_cert": {
      "desc": "TLS/DTLS 服务器与 {verify，verify_peer} 一起使用。\n如果设置为 true，则如果客户端没有要发送的证书，即发送空证书，服务器将失败。\n如果设置为 false，则仅当客户端发送无效证书（空证书被视为有效证书）时才会失败。",
      "label": "没有证书则 SSL 失败"
    },
    "server_ssl_opts_schema_gc_after_handshake": {
      "desc": "内存使用调优。如果启用，将在 TLS/SSL 握手完成后立即执行垃圾回收。TLS/SSL 握手建立后立即进行 GC。",
      "label": "握手后执行 GC"
    },
    "server_ssl_opts_schema_handshake_timeout": {
      "desc": "握手完成所允许的最长时间",
      "label": "握手超时时间"
    },
    "server_ssl_opts_schema_honor_cipher_order": {
      "desc": "一个重要的安全设置，它强制根据服务器指定的顺序而不是客户机指定的顺序设置密码，从而强制服务器管理员执行（通常配置得更正确）安全顺序。",
      "label": "SSL honor cipher order"
    },
    "server_ssl_opts_schema_ocsp_issuer_pem": {
      "desc": "服务器证书的 OCSP 签发者的 PEM 编码证书。",
      "label": "OCSP 签发者证书"
    },
    "server_ssl_opts_schema_ocsp_refresh_http_timeout": {
      "desc": "检查 OCSP 响应时，HTTP 请求的超时。",
      "label": "OCSP 刷新 HTTP 超时"
    },
    "server_ssl_opts_schema_ocsp_refresh_interval": {
      "desc": "为服务器刷新 OCSP 响应的周期。",
      "label": "OCSP 刷新间隔"
    },
    "server_ssl_opts_schema_ocsp_responder_url": {
      "desc": "用于检查服务器证书的 OCSP Responder 的 URL。",
      "label": "OCSP Responder 的 URL"
    },
    "shared_subscription_group_strategy": {
      "desc": "设置共享订阅组为单位的分发策略。该配置是一个从组名到\n策略名的一个 map，组名不得包含 `[A-Za-z0-9]` 之外的特殊字符。"
    },
    "shared_subscription_strategy_enum": {
      "desc": "共享订阅的分发策略名称。\n- `random`：随机选择一个组内成员；\n- `round_robin`：循环选择下一个成员；\n- `round_robin_per_group`：在共享组内循环选择下一个成员；\n- `sticky`：使用上一次选中的成员；\n- `hash`：根据 ClientID 哈希映射到一个成员；\n- `local`：随机分发到节点本地成成员，如果本地成员不存在，则随机分发到任意一个成员"
    },
    "stats_enable": {
      "desc": "启用/禁用统计数据收集功能。",
      "label": "启用/禁用统计数据收集功能"
    },
    "sys_event_client_connected": {
      "desc": "是否开启客户端已连接事件消息。"
    },
    "sys_event_client_disconnected": {
      "desc": "是否开启客户端已断开连接事件消息。"
    },
    "sys_event_client_subscribed": {
      "desc": "是否开启客户端已成功订阅主题事件消息。"
    },
    "sys_event_client_unsubscribed": {
      "desc": "是否开启客户端已成功取消订阅主题事件消息。"
    },
    "sys_event_messages": {
      "desc": "客户端事件消息。"
    },
    "sys_heartbeat_interval": {
      "desc": "发送心跳系统消息的间隔时间，它包括：\n  - `$SYS/brokers/<node>/uptime`\n  - `$SYS/brokers/<node>/datetime`"
    },
    "sys_msg_interval": {
      "desc": "发送 `$SYS` 主题的间隔时间。"
    },
    "sys_topics": {
      "desc": "系统主题配置。"
    },
    "sysmon_os_cpu_check_interval": {
      "desc": "定期 CPU 检查的时间间隔。",
      "label": "定期 CPU 检查的时间间隔"
    },
    "sysmon_os_cpu_high_watermark": {
      "desc": "在发出相应警报之前可以使用多少系统 CPU 的阈值，以系统 CPU 负载的百分比表示。",
      "label": "CPU 高水位线"
    },
    "sysmon_os_cpu_low_watermark": {
      "desc": "在解除相应警报之前可以使用多少系统 CPU 的阈值，以系统 CPU 负载的百分比表示。",
      "label": "CPU 低水位线"
    },
    "sysmon_os_mem_check_interval": {
      "desc": "定期内存检查的时间间隔。",
      "label": "内存检查间隔"
    },
    "sysmon_os_procmem_high_watermark": {
      "desc": "在发出相应警报之前，一个 Erlang 进程可以分配多少系统内存的阈值，以系统内存的百分比表示。",
      "label": "进程内存高水位线"
    },
    "sysmon_os_sysmem_high_watermark": {
      "desc": "在发出相应报警之前可以分配多少系统内存的阈值，以系统内存的百分比表示。",
      "label": "系统内存高水位线"
    },
    "sysmon_top_db_hostname": {
      "desc": "收集数据点的 PostgreSQL 数据库的主机名。",
      "label": "数据库主机名"
    },
    "sysmon_top_db_name": {
      "desc": "PostgreSQL 数据库的数据库名",
      "label": "数据库名"
    },
    "sysmon_top_db_password": {
      "desc": "PostgreSQL 数据库的密码",
      "label": "数据库密码"
    },
    "sysmon_top_db_port": {
      "desc": "收集数据点的 PostgreSQL 数据库的端口。",
      "label": "数据库端口"
    },
    "sysmon_top_db_username": {
      "desc": "PostgreSQL 数据库的用户名",
      "label": "数据库用户名"
    },
    "sysmon_top_max_procs": {
      "desc": "当 VM 中的进程数超过此值时，停止收集数据。",
      "label": "最大进程数"
    },
    "sysmon_top_num_items": {
      "desc": "每个监视组的顶级进程数。",
      "label": "顶级进程数"
    },
    "sysmon_top_sample_interval": {
      "desc": "指定应收集进程顶部的频率。",
      "label": "取样时间"
    },
    "sysmon_vm_busy_dist_port": {
      "desc": "启用后，当用于集群接点之间 RPC 的连接过忙时，会触发一条带有 <code>busy_dist_port</code> 关键字的 warning 级别日志。\n同时还会发布一条主题为 <code>$SYS/sysmon/busy_dist_port</code> 的 MQTT 系统消息。",
      "label": "启用分布式端口过忙监控"
    },
    "sysmon_vm_busy_port": {
      "desc": "当一个系统接口（例如 TCP socket）过忙，会触发一条带有 <code>busy_port</code> 关键字的 warning 级别的日志。\n同时还会发布一条主题为 <code>$SYS/sysmon/busy_port</code> 的 MQTT 系统消息。",
      "label": "启用端口过忙监控"
    },
    "sysmon_vm_large_heap": {
      "desc": "启用后，当一个 Erlang 进程申请了大量内存，系统会触发一条带有 <code>large_heap</code> 关键字的\nwarning 级别日志。同时还会发布一条主题为 <code>$SYS/sysmon/busy_dist_port</code> 的 MQTT 系统消息。",
      "label": "启用大 heap 监控"
    },
    "sysmon_vm_long_gc": {
      "desc": "当系统检测到某个 Erlang 进程垃圾回收占用过长时间，会触发一条带有 <code>long_gc</code> 关键字的日志。\n同时还会发布一条主题为 <code>$SYS/sysmon/long_gc</code> 的 MQTT 系统消息。",
      "label": "启用长垃圾回收监控"
    },
    "sysmon_vm_long_schedule": {
      "desc": "启用后，如果 Erlang VM 调度器出现某个任务占用时间过长时，会触发一条带有 'long_schedule' 关键字的日志。\n同时还会发布一条主题为 <code>$SYS/sysmon/long_schedule</code> 的 MQTT 系统消息。",
      "label": "启用长调度监控"
    },
    "sysmon_vm_process_check_interval": {
      "desc": "定期进程限制检查的时间间隔。",
      "label": "进程限制检查时间"
    },
    "sysmon_vm_process_high_watermark": {
      "desc": "在发出相应警报之前，本地节点上可以同时存在多少进程的阈值（以进程百分比表示）。",
      "label": "进程数高水位线"
    },
    "sysmon_vm_process_low_watermark": {
      "desc": "在清除相应警报之前，本地节点上可以同时存在多少进程的阈值（以进程百分比表示）。",
      "label": "进程数低水位线"
    },
    "zones": {
      "desc": "<code>zone</code> 是按<code>name</code> 分组的一组配置。\n对于灵活的配置映射，可以将 <code>name</code> 设置为监听器的 <code>zone</code> 配置。\n注：名为 <code>default</code> 的内置区域是自动创建的，无法删除。"
    }
  },
  "emqx_slow_subs_api": {
    "clear_records_api": {
      "desc": "清除当前记录，然后重新开始统计",
      "label": "清除当前记录，然后重新开始统计"
    },
    "clientid": {
      "desc": "消息的客户端 ID"
    },
    "get_records_api": {
      "desc": "查看慢订阅的统计数据",
      "label": "查看慢订阅的统计数据"
    },
    "get_setting_api": {
      "desc": "查看配置",
      "label": "查看配置"
    },
    "last_update_time": {
      "desc": "记录的更新时间戳"
    },
    "node": {
      "desc": "消息的节点名称"
    },
    "timespan": {
      "desc": "消息的传输耗时"
    },
    "topic": {
      "desc": "消息的主题"
    },
    "update_setting_api": {
      "desc": "更新配置",
      "label": "更新配置"
    }
  },
  "emqx_slow_subs_schema": {
    "enable": {
      "desc": "开启慢订阅"
    },
    "expire_interval": {
      "desc": "慢订阅记录的有效时间"
    },
    "stats_type": {
      "desc": "慢订阅的统计类型"
    },
    "threshold": {
      "desc": "慢订阅统计的阈值"
    },
    "top_k_num": {
      "desc": "慢订阅统计表的记录数量上限"
    }
  },
  "emqx_stomp_schema": {
    "stom_frame_max_body_length": {
      "desc": "允许的 Stomp 报文 Body 的最大字节数"
    },
    "stom_frame_max_headers": {
      "desc": "允许的 Header 最大数量"
    },
    "stomp": {
      "desc": "Stomp 网关配置。当前实现支持 v1.2/1.1/1.0 协议版本"
    },
    "stomp_frame_max_headers_length": {
      "desc": "允许的 Header 字符串的最大长度"
    }
  },
  "emqx_telemetry_api": {
    "active_modules": {
      "desc": "活跃模块"
    },
    "active_plugins": {
      "desc": "活跃插件"
    },
    "emqx_version": {
      "desc": "EMQX 版本"
    },
    "enable": {
      "desc": "启用遥测"
    },
    "get_telemetry_data_api": {
      "desc": "获取遥测数据示例",
      "label": "获取遥测数据示例"
    },
    "get_telemetry_status_api": {
      "desc": "获取遥测启用状态",
      "label": "获取遥测启用状态"
    },
    "license": {
      "desc": "License 信息"
    },
    "messages_received": {
      "desc": "接收到的消息数量"
    },
    "messages_sent": {
      "desc": "发送的消息数量"
    },
    "nodes_uuid": {
      "desc": "节点 UUID"
    },
    "num_clients": {
      "desc": "客户端数量"
    },
    "os_name": {
      "desc": "操作系统名称"
    },
    "os_version": {
      "desc": "操作系统版本"
    },
    "otp_version": {
      "desc": "OTP 版本"
    },
    "up_time": {
      "desc": "运行时间"
    },
    "update_telemetry_status_api": {
      "desc": "更新遥测状态",
      "label": "更新遥测状态"
    },
    "uuid": {
      "desc": "UUID"
    }
  },
  "emqx_telemetry_schema": {
    "enable": {
      "desc": "设置为 `false` 可以关闭数据发送。"
    },
    "telemetry_root_doc": {
      "desc": "配置 EMQX 节点向 EMQ 的遥测服务器发送遥测数据。\n详情请参考 https://www.emqx.io/docs/zh/v5.1/telemetry/telemetry.html。"
    }
  },
  "emqx_topic_metrics_api": {
    "action": {
      "desc": "仅支持 reset 重置数据",
      "label": "操作"
    },
    "create_time": {
      "desc": "创建时间。标准 rfc3339 时间格式，例如：2018-01-01T12:00:00Z",
      "label": "创建时间"
    },
    "delete_topic_metrics_data_api": {
      "desc": "删除主题监控",
      "label": "删除主题监控"
    },
    "gat_topic_metrics_data_api": {
      "desc": "获取主题监控数据",
      "label": "获取主题监控数据"
    },
    "get_topic_metrics_api": {
      "desc": "获取主题监控数据",
      "label": "获取主题监控数据"
    },
    "message_dropped_count": {
      "desc": "消息丢弃数量",
      "label": "消息丢弃数量"
    },
    "message_dropped_rate": {
      "desc": "消息丢弃速率",
      "label": "消息丢弃速率"
    },
    "message_in_count": {
      "desc": "消息流入数量",
      "label": "消息流入数量"
    },
    "message_in_rate": {
      "desc": "消息流入速率",
      "label": "消息流入速率"
    },
    "message_out_count": {
      "desc": "消息发出总数",
      "label": "消息发出总数"
    },
    "message_out_rate": {
      "desc": "消息流出速率",
      "label": "消息流出速率"
    },
    "message_qos0_in_count": {
      "desc": "QoS0 消息流入数量",
      "label": "QoS0 消息流入数量"
    },
    "message_qos0_in_rate": {
      "desc": "QoS0 消息流入速率",
      "label": "QoS0 消息流入速率"
    },
    "message_qos0_out_count": {
      "desc": "QoS0 消息流出数量",
      "label": "QoS0 消息流出数量"
    },
    "message_qos0_out_rate": {
      "desc": "QoS0 消息流出速率",
      "label": "QoS0 消息流出速率"
    },
    "message_qos1_in_count": {
      "desc": "QoS1 消息流入数量",
      "label": "QoS1 消息流入数量"
    },
    "message_qos1_in_rate": {
      "desc": "QoS1 消息流入速率",
      "label": "QoS1 消息流入速率"
    },
    "message_qos1_out_count": {
      "desc": "QoS1 消息流出数量",
      "label": "QoS1 消息流出数量"
    },
    "message_qos1_out_rate": {
      "desc": "QoS1 消息流出速率",
      "label": "QoS1 消息流出速率"
    },
    "message_qos2_in_count": {
      "desc": "QoS2 消息流入数量",
      "label": "QoS2 消息流入数量"
    },
    "message_qos2_in_rate": {
      "desc": "QoS2 消息流入速率",
      "label": "QoS2 消息流入速率"
    },
    "message_qos2_out_count": {
      "desc": "QoS2 消息流出数量",
      "label": "QoS2 消息流出数量"
    },
    "message_qos2_out_rate": {
      "desc": "QoS2 消息流出速率",
      "label": "QoS2 消息流出速率"
    },
    "metrics": {
      "desc": "监控数据",
      "label": "监控数据"
    },
    "post_topic_metrics_api": {
      "desc": "添加主题监控，不支持通配符主题。",
      "label": "添加主题监控"
    },
    "reset_time": {
      "desc": "重置时间。标准 rfc3339 时间格式，例如：2018-01-01T12:00:00Z。如果从未重置则为空",
      "label": "重置时间"
    },
    "reset_topic_desc": {
      "desc": "如果不设置主题，则重置所有主题监控数据。",
      "label": "要重置的主题"
    },
    "reset_topic_metrics_api": {
      "desc": "重置主题监控数据",
      "label": "重置主题监控数据"
    },
    "topic": {
      "desc": "主题",
      "label": "主题"
    },
    "topic_in_body": {
      "desc": "主题，不支持通配符",
      "label": "主题"
    },
    "topic_in_path": {
      "desc": "主题字符串。注意：URL 路径中的主题字符串必须进行编码",
      "label": "主题字符串"
    },
    "topic_metrics_api_response400": {
      "desc": "错误请求，已存在或错误的主题名称",
      "label": "错误请求"
    },
    "topic_metrics_api_response404": {
      "desc": "该主题未添加到主题监控列表中。",
      "label": "主题监控不存在"
    },
    "topic_metrics_api_response409": {
      "desc": "最多只能监控 512 个主题",
      "label": "超出主题监控上线"
    }
  }
}
